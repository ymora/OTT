"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4767],{4807:function(e,r,t){t.d(r,{s:function(){return s}});var a=t(2265),i=t(542),n=t(8828),l=t(9629);function s(){let[e,r]=(0,a.useState)(null),[t,s]=(0,a.useState)(!1),[o,u]=(0,a.useState)([]),[c,d]=(0,a.useState)(null),g=(0,a.useRef)(null),m=(0,a.useRef)(null),b=(0,a.useRef)(null),f=(0,a.useRef)(!1),v=(0,a.useRef)(null),w="undefined"!=typeof navigator&&"serial"in navigator;(0,a.useEffect)(()=>{{b.current=(0,l.T)();let a=b.current.on("state-changed",async a=>{let i=f.current;if(f.current=a.isMaster,n.Z.debug("[SerialPortManager] State changed:",a),!a.isMaster&&i&&t&&e){n.Z.warn("[SerialPortManager] No longer master, closing port automatically...");try{if(g.current){try{await g.current.cancel(),await g.current.release()}catch(e){}g.current=null}if(m.current){try{await m.current.release()}catch(e){}m.current=null}if(e)try{await e.close()}catch(e){}s(!1),r(null),n.Z.debug("[SerialPortManager] Port closed after losing master status")}catch(e){n.Z.error("[SerialPortManager] Error closing port after losing master status:",e)}}}),i=b.current.on("data-received",e=>{f.current||(v.current=e,n.Z.debug("[SerialPortManager] Data received from master tab"))});return()=>{a(),i()}}},[t]);let _=(0,a.useCallback)(async()=>{if(!w)return d("Web Serial API non support\xe9 par ce navigateur. Utilisez Chrome ou Edge."),null;try{var e;d(null);let t=(0,i.Yu)(),a=t.length>0?{filters:t}:void 0,l=await navigator.serial.requestPort(a);r(l);let s=null==l?void 0:null===(e=l.getInfo)||void 0===e?void 0:e.call(l),o=(0,i.DE)(s);return o&&n.Z.log("[USB] Port s\xe9lectionn\xe9: ".concat(o)),l}catch(e){return"NotFoundError"!==e.name&&d("Erreur lors de la s\xe9lection du port: ".concat(e.message)),null}},[w]),p=(0,a.useCallback)(async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:115200,i=t||e;if(!i)return d("Aucun port s\xe9lectionn\xe9"),!1;if(b.current){let e=b.current;if(e.checkState(),e.isMaster)f.current=!0,n.Z.debug("[SerialPortManager] Already master, can open port");else{if(n.Z.debug("[SerialPortManager] Not master, requesting master status..."),!await e.requestMaster())return n.Z.warn("[SerialPortManager] Port already open in another tab, listening to shared data only"),s(!0),r(null),d(null),!0;f.current=!0,n.Z.debug("[SerialPortManager] Became master, can open port")}}else f.current=!0;try{if(d(null),m.current){try{await m.current.release()}catch(e){}m.current=null}if(g.current){try{await g.current.cancel(),await g.current.release()}catch(e){}g.current=null}if(i.readable&&i.writable){if(n.Z.debug("[SerialPortManager] connect: port d\xe9j\xe0 ouvert dans cet onglet, v\xe9rification des locks..."),n.Z.debug("[SerialPortManager] connect: writable.locked =",i.writable.locked),n.Z.debug("[SerialPortManager] connect: readable.locked =",i.readable.locked),i.writable.locked||i.readable.locked){if(b.current&&(b.current.checkState(),!b.current.isMaster)||!f.current)return n.Z.warn("[SerialPortManager] connect: port verrouill\xe9 mais on n'est pas master - un autre onglet a le port"),d(null),s(!0),r(null),!0;n.Z.warn("[SerialPortManager] connect: port verrouill\xe9, fermeture compl\xe8te n\xe9cessaire...");try{if(m.current){try{await m.current.release()}catch(e){n.Z.warn("[SerialPortManager] connect: erreur release writer:",e)}m.current=null}if(g.current){try{await g.current.cancel(),await g.current.release()}catch(e){n.Z.warn("[SerialPortManager] connect: erreur release reader:",e)}g.current=null}n.Z.debug("[SerialPortManager] connect: fermeture du port pour le rouvrir...");try{await i.close(),n.Z.debug("[SerialPortManager] connect: port ferm\xe9, attente 500ms..."),await new Promise(e=>setTimeout(e,500))}catch(e){n.Z.warn("[SerialPortManager] connect: erreur fermeture port:",e)}n.Z.debug("[SerialPortManager] connect: port sera rouvert apr\xe8s la fermeture")}catch(e){return n.Z.error("[SerialPortManager] connect: erreur nettoyage:",e),d("Erreur lors du nettoyage du port: ".concat(e.message)),!1}}else{n.Z.debug("[SerialPortManager] connect: port non verrouill\xe9, r\xe9utilisation...");try{n.Z.debug("[SerialPortManager] connect: cr\xe9ation du writer...");let e=i.writable.getWriter();m.current=e,n.Z.debug("[SerialPortManager] connect: cr\xe9ation du reader...");let t=i.readable.getReader();return g.current=t,s(!0),r(i),b.current&&f.current&&b.current.notifyPortOpened({baudRate:a,timestamp:Date.now()}),n.Z.debug("[SerialPortManager] connect: ✅ port r\xe9utilis\xe9 avec succ\xe8s"),!0}catch(e){return n.Z.error("[SerialPortManager] connect: erreur r\xe9utilisation port:",e),d("Erreur lors de la r\xe9utilisation du port: ".concat(e.message)),s(!1),!1}}}n.Z.debug("[SerialPortManager] connect: ouverture du port...");try{await i.open({baudRate:a}),n.Z.debug("[SerialPortManager] connect: port ouvert")}catch(e){if("InvalidStateError"===e.name&&i.readable&&i.writable){if(n.Z.debug("[SerialPortManager] connect: port d\xe9j\xe0 ouvert (InvalidStateError), r\xe9utilisation..."),i.writable.locked||i.readable.locked)return d("Port toujours verrouill\xe9 apr\xe8s nettoyage. Attendez quelques secondes et r\xe9essayez."),n.Z.error("[SerialPortManager] connect: port toujours verrouill\xe9 apr\xe8s nettoyage"),s(!1),!1}else throw e}n.Z.debug("[SerialPortManager] connect: cr\xe9ation du writer...");let e=i.writable.getWriter();m.current=e,n.Z.debug("[SerialPortManager] connect: writer cr\xe9\xe9"),n.Z.debug("[SerialPortManager] connect: cr\xe9ation du reader...");let t=i.readable.getReader();return g.current=t,n.Z.debug("[SerialPortManager] connect: reader cr\xe9\xe9"),s(!0),r(i),n.Z.debug("[SerialPortManager] connect: ✅ connexion r\xe9ussie"),!0}catch(e){if("InvalidStateError"===e.name&&i.readable&&i.writable)try{if(i.writable.locked||i.readable.locked)return d("Port d\xe9j\xe0 utilis\xe9 par une autre connexion. D\xe9connectez d'abord."),s(!1),!1;let e=i.writable.getWriter();m.current=e;let t=i.readable.getReader();return g.current=t,s(!0),r(i),!0}catch(e){return d("Erreur de connexion (port d\xe9j\xe0 ouvert): ".concat(e.message)),s(!1),!1}return d("Erreur de connexion: ".concat(e.message)),s(!1),!1}},[e]),h=(0,a.useCallback)(async()=>{n.Z.debug("[SerialPortManager] disconnect: d\xe9but");try{if(g.current){n.Z.debug("[SerialPortManager] disconnect: arr\xeat du reader...");try{await g.current.cancel()}catch(e){n.Z.warn("[SerialPortManager] disconnect: erreur cancel reader:",e)}try{await g.current.release()}catch(e){n.Z.warn("[SerialPortManager] disconnect: erreur release reader:",e)}g.current=null,n.Z.debug("[SerialPortManager] disconnect: reader lib\xe9r\xe9")}if(m.current){n.Z.debug("[SerialPortManager] disconnect: lib\xe9ration du writer...");try{await m.current.release()}catch(e){n.Z.warn("[SerialPortManager] disconnect: erreur release writer:",e)}m.current=null,n.Z.debug("[SerialPortManager] disconnect: writer lib\xe9r\xe9")}if(e){n.Z.debug("[SerialPortManager] disconnect: fermeture du port...");try{await e.close(),n.Z.debug("[SerialPortManager] disconnect: port ferm\xe9")}catch(e){n.Z.warn("[SerialPortManager] disconnect: erreur fermeture port:",e)}}s(!1),r(null),d(null),b.current&&f.current&&(b.current.notifyPortClosed(),f.current=!1,n.Z.debug("[SerialPortManager] Notified port sharing system (port closed)")),n.Z.debug("[SerialPortManager] disconnect: ✅ d\xe9connexion compl\xe8te")}catch(e){n.Z.error("[SerialPortManager] disconnect: ❌ erreur:",e),d("Erreur de d\xe9connexion: ".concat(e.message))}},[e]),S=(0,a.useCallback)(async r=>{let a=e&&e.readable&&e.writable,i=g.current;if(n.Z.debug("[SerialPortManager] startReading: v\xe9rifications..."),n.Z.debug("[SerialPortManager] startReading: isConnected =",t),n.Z.debug("[SerialPortManager] startReading: port existe =",!!e),n.Z.debug("[SerialPortManager] startReading: port.readable =",!!(null==e?void 0:e.readable)),n.Z.debug("[SerialPortManager] startReading: port.writable =",!!(null==e?void 0:e.writable)),n.Z.debug("[SerialPortManager] startReading: readerRef.current =",!!g.current),!a&&!i)return n.Z.error("[SerialPortManager] startReading: Port non disponible (port:",!!e,"readable:",!!(null==e?void 0:e.readable),"writable:",!!(null==e?void 0:e.writable),"reader:",!!g.current,")"),d("Port non disponible. Le port doit \xeatre connect\xe9 avant de d\xe9marrer la lecture."),()=>{};if(!g.current&&a){n.Z.debug("[SerialPortManager] startReading: cr\xe9ation du reader...");try{if(e.readable.locked)return n.Z.error("[SerialPortManager] startReading: readable est verrouill\xe9"),d("Port readable verrouill\xe9. D\xe9connectez et reconnectez."),()=>{};g.current=e.readable.getReader(),n.Z.debug("[SerialPortManager] startReading: reader cr\xe9\xe9")}catch(e){return n.Z.error("[SerialPortManager] startReading: erreur cr\xe9ation reader:",e),d("Erreur cr\xe9ation reader: ".concat(e.message)),()=>{}}}if(!g.current)return n.Z.error("[SerialPortManager] startReading: Reader non disponible apr\xe8s tentative de cr\xe9ation"),d("Reader non disponible. Le port doit \xeatre connect\xe9 avant de d\xe9marrer la lecture."),()=>{};let l=!0,s=!0,o=0;return(async()=>{try{for(n.Z.debug("[SerialPortManager] D\xe9marrage de la boucle de lecture...");l&&s;){if(!g.current){n.Z.warn("[SerialPortManager] Reader perdu, arr\xeat de la lecture");break}try{let{value:e,done:t}=await g.current.read();if(o=0,t){n.Z.debug("[SerialPortManager] Stream termin\xe9 (done=true)");break}if(e&&r){let t=new TextDecoder().decode(e);t&&t.length>0&&(n.Z.debug("[SerialPortManager] Donn\xe9es re\xe7ues: ".concat(t.length," caract\xe8res")),r(t))}}catch(r){var e;if("NetworkError"===r.name){n.Z.debug("[SerialPortManager] Erreur r\xe9seau (d\xe9connexion probable)");break}if("TypeError"===r.name&&r.message.includes("cancel")){n.Z.debug("[SerialPortManager] Lecture annul\xe9e");break}if("FramingError"===r.name||(null===(e=r.message)||void 0===e?void 0:e.includes("Framing"))){if(++o<=3){n.Z.debug("[SerialPortManager] Erreur de framing ignor\xe9e (".concat(o,"/3)")),await new Promise(e=>setTimeout(e,50));continue}if(4===o){n.Z.warn("[SerialPortManager] Erreurs de framing d\xe9tect\xe9es (continuation silencieuse...)"),await new Promise(e=>setTimeout(e,100));continue}if(o%100==0){n.Z.debug("[SerialPortManager] ".concat(o," erreurs de framing (continuation...)")),await new Promise(e=>setTimeout(e,100));continue}await new Promise(e=>setTimeout(e,100));continue}if(o++,1===o)n.Z.error("[SerialPortManager] Erreur lors de la lecture:",r);else if(o>=5){n.Z.error("[SerialPortManager] Trop d'erreurs cons\xe9cutives (".concat(o,"), arr\xeat de la lecture")),d("Erreur de lecture r\xe9p\xe9t\xe9e: ".concat(r.message));break}else n.Z.debug("[SerialPortManager] Erreur ".concat(o,"/").concat(5,":"),r.message);await new Promise(e=>setTimeout(e,100))}}n.Z.debug("[SerialPortManager] Boucle de lecture termin\xe9e")}catch(e){n.Z.error("[SerialPortManager] Erreur dans la boucle de lecture:",e),"NetworkError"!==e.name&&l&&d("Erreur de lecture: ".concat(e.message))}finally{s=!1}})().catch(e=>{n.Z.error("[SerialPortManager] Erreur non g\xe9r\xe9e dans readLoop:",e),s=!1}),()=>{n.Z.debug("[SerialPortManager] Arr\xeat de la lecture demand\xe9"),l=!1,s=!1}},[t,d]),y=(0,a.useCallback)(async r=>{var a,i;if(n.Z.debug("[SerialPortManager] write: appel\xe9 avec","string"==typeof r?r.length:"non-string","caract\xe8res"),n.Z.debug("[SerialPortManager] write: writerRef.current existe?",!!m.current),n.Z.debug("[SerialPortManager] write: port existe?",!!e),n.Z.debug("[SerialPortManager] write: port.writable existe?",!!(null==e?void 0:e.writable)),n.Z.debug("[SerialPortManager] write: port.writable.locked?",null==e?void 0:null===(a=e.writable)||void 0===a?void 0:a.locked),n.Z.debug("[SerialPortManager] write: isConnected?",t),"string"!=typeof r){let e="Les donn\xe9es doivent \xeatre une string";return d(e),n.Z.error("[SerialPortManager] write:",e,"type re\xe7u:",typeof r),!1}if(!m.current){if(n.Z.warn("[SerialPortManager] write: writerRef.current est null, tentative de cr\xe9ation..."),!e||!e.writable){let r="Port non connect\xe9 ou writer non disponible";return d(r),n.Z.error("[SerialPortManager] write:",r,"port:",!!e,"writable:",!!(null==e?void 0:e.writable)),!1}try{if(e.writable&&!e.writable.locked)n.Z.debug("[SerialPortManager] write: cr\xe9ation d'un nouveau writer..."),m.current=e.writable.getWriter(),n.Z.debug("[SerialPortManager] write: writer cr\xe9\xe9 avec succ\xe8s");else{let r="Port writable verrouill\xe9 ou non disponible";return d(r),n.Z.error("[SerialPortManager] write:",r,"locked:",null===(i=e.writable)||void 0===i?void 0:i.locked),!1}}catch(r){let e="Erreur cr\xe9ation writer: ".concat(r.message);return d(e),n.Z.error("[SerialPortManager] write:",e,r),!1}}try{let e=new TextEncoder().encode(r);return n.Z.debug("[SerialPortManager] write: envoi de",e.length,"bytes via writerRef.current"),n.Z.debug("[SerialPortManager] write: contenu (hex):",Array.from(e).map(e=>e.toString(16).padStart(2,"0")).join(" ")),n.Z.debug("[SerialPortManager] write: contenu (ascii):",r.replace(/\n/g,"\\n").replace(/\r/g,"\\r")),await m.current.write(e),n.Z.debug("[SerialPortManager] write: ✅ donn\xe9es envoy\xe9es avec succ\xe8s"),!0}catch(e){if(d("Erreur d'\xe9criture: ".concat(e.message)),n.Z.error("[SerialPortManager] write: ❌ erreur lors de l'\xe9criture:",e),"NetworkError"===e.name||e.message.includes("writer")){n.Z.warn("[SerialPortManager] write: r\xe9initialisation du writer apr\xe8s erreur");try{await m.current.release()}catch(e){n.Z.warn("[SerialPortManager] write: erreur release writer:",e)}m.current=null}return!1}},[e,t]);return(0,a.useEffect)(()=>()=>{t&&h()},[t,h]),{port:e,isConnected:t,isSupported:w,error:c,requestPort:_,connect:p,disconnect:h,startReading:S,write:y}}},4767:function(e,r,t){t.d(r,{d:function(){return c},l:function(){return d}});var a=t(7437),i=t(2265),n=t(4807),l=t(9999),s=t(8828),o=t(9629);let u=(0,i.createContext)();function c(e){let{children:r}=e,{port:c,isConnected:d,isSupported:g,requestPort:m,connect:b,disconnect:f,startReading:v,write:w}=(0,n.s)(),{fetchWithAuth:_,API_URL:p}=(0,l.a)(),[h,S]=(0,i.useState)(null),[y,Z]=(0,i.useState)(null),[D,P]=(0,i.useState)(null),[M,I]=(0,i.useState)(!0),[E,U]=(0,i.useState)(!1),[C,B]=(0,i.useState)(null),[T,k]=(0,i.useState)("idle"),[A,R]=(0,i.useState)([]),[q,O]=(0,i.useState)([]),[N,x]=(0,i.useState)(null),[j,L]=(0,i.useState)(null),[J,V]=(0,i.useState)(null),F=(0,i.useRef)(null),H=(0,i.useRef)(""),X=(0,i.useRef)(null),W=(0,i.useRef)(null),z=(0,i.useRef)(null),G=(0,i.useRef)([]);(0,i.useEffect)(()=>{{z.current=(0,o.T)();let e=z.current.on("data-received",e=>{s.Z.debug("[UsbContext] Data received from master tab:",e),e.measurement&&(L(e.measurement),V(Date.now()),R(r=>[...r,e.measurement].slice(-120))),e.deviceInfo&&B(e.deviceInfo)});return()=>{e()}}},[]);let Y=(0,i.useCallback)(function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"device";if(!e)return;let t=Date.now();O(a=>[...a,{id:"".concat(t,"-").concat(Math.random()),line:e,timestamp:t,source:r}].slice(-80))},[]),K=(0,i.useCallback)(()=>{O([]),s.Z.log("\uD83D\uDDD1️ Console USB effac\xe9e"),(h||y)&&X.current&&(G.current.push({log_line:line,log_source:source,timestamp:timestamp}),G.current.length>200&&(G.current=G.current.slice(-200)))},[h,y]),Q=(0,i.useCallback)(async()=>{if(!g)throw Error("Web Serial API non support\xe9e par ce navigateur");if(c&&d||c&&!d&&await b(c,115200))return c;let e=await m();if(!e)throw Error("Aucun port USB s\xe9lectionn\xe9");if(!await b(e,115200))throw Error("Impossible de se connecter au port USB s\xe9lectionn\xe9");return e},[b,d,g,c,m]),$=(0,i.useCallback)(async()=>{if(0===G.current.length)return;let e=h||y;if(!e||!X.current)return;let r=e.sim_iccid||e.device_serial||e.device_name;if(!r){s.Z.warn("⚠️ Impossible d'envoyer les logs : aucun identifiant de dispositif");return}let a=[...G.current];G.current=[];try{let{fetchJson:i}=await t.e(2617).then(t.bind(t,2617)),n=await fetch("/api.php/usb-logs",{method:"POST",headers:{"Content-Type":"application/json",Authorization:"Bearer ".concat(localStorage.getItem("token")||"")},body:JSON.stringify({device_identifier:r,device_name:e.device_name,logs:a})});if(n.ok){let e=await n.json();s.Z.debug("✅ ".concat(e.inserted_count||a.length," logs USB envoy\xe9s au serveur"))}else{let e=await n.json().catch(()=>({}));s.Z.warn("⚠️ Erreur envoi logs USB:",n.status,e),G.current=[...a,...G.current].slice(-200)}}catch(e){s.Z.error("❌ Erreur envoi logs USB au serveur:",e),G.current=[...a,...G.current].slice(-200)}},[h,y]);(0,i.useEffect)(()=>{let e=setInterval(()=>{$()},5e3);return()=>{clearInterval(e),G.current.length>0&&$()}},[$]),(0,i.useEffect)(()=>{if(!d||!h||!w||!_||!p)return;let e=async()=>{try{let e=h.sim_iccid||h.device_serial;if(!e)return;let r=await _("".concat(p,"/api.php/devices/").concat(e,"/commands?status=pending&limit=5"),{method:"GET"},{requiresAuth:!0});if(!r.ok)return;let t=await r.json();if(!t.success||!t.commands||0===t.commands.length)return;for(let e of t.commands)if("UPDATE_CONFIG"===e.command&&e.payload){let r="string"==typeof e.payload?JSON.parse(e.payload):e.payload,t="config ".concat(JSON.stringify(r),"\n");await w(t),s.Z.log("\uD83D\uDCE4 [USB] Commande UPDATE_CONFIG envoy\xe9e:",r)}}catch(e){s.Z.debug("Erreur v\xe9rification commandes USB:",e)}},r=setInterval(e,5e3);return e(),()=>clearInterval(r)},[d,h,w,_,p]);let ee=(0,i.useCallback)(async(e,r)=>{if(!r||!X.current){s.Z.debug("⚠️ Pas de dispositif ou callback pour envoyer la mesure USB");return}try{var a,i,n,l,o;let u=r.sim_iccid;if((!u||"N/A"===u||u.length<10)&&(u=r.device_serial,s.Z.debug("\uD83D\uDCDD Utilisation device_serial comme ICCID:",u)),!u||"N/A"===u){let e=null===(i=r.device_name)||void 0===i?void 0:i.match(/USB-([a-f0-9:]+)/i);e&&e[1]?(u=e[1],s.Z.debug("\uD83D\uDCDD Utilisation device_name comme ICCID:",u)):u=r.device_name}if(!u||"N/A"===u){s.Z.warn("❌ Impossible d'envoyer la mesure USB: pas d'identifiant disponible",{device_name:r.device_name,sim_iccid:r.sim_iccid,device_serial:r.device_serial});return}let c=(null===(a=e.raw)||void 0===a?void 0:a.firmware_version)||r.firmware_version||null,d={sim_iccid:String(u).trim(),flowrate:null!==(n=e.flowrate)&&void 0!==n?n:0,battery:null!==(l=e.battery)&&void 0!==l?l:null,rssi:null!==(o=e.rssi)&&void 0!==o?o:null,firmware_version:c,timestamp:new Date(e.timestamp).toISOString(),status:"USB"};null!=e.latitude&&null!=e.longitude&&(d.latitude=e.latitude,d.longitude=e.longitude),s.Z.debug("\uD83D\uDCE4 Envoi mesure USB \xe0 l'API:",d);let{sendMeasurementWithRetry:g}=await t.e(7546).then(t.bind(t,7546)),m=await g(d,X.current);m.success?s.Z.debug("✅ Mesure USB envoy\xe9e avec succ\xe8s"):m.queued?s.Z.info("\uD83D\uDCE6 Mesure USB mise en queue pour retry ult\xe9rieur"):s.Z.warn("⚠️ \xc9chec envoi mesure USB:",m.error)}catch(e){s.Z.error("❌ Erreur envoi mesure USB \xe0 l'API:",e,{device:r})}},[]),er=(0,i.useCallback)(e=>{if(!e){s.Z.debug("processUsbStreamLine: ligne vide");return}let r=e.trim();if(!r){s.Z.debug("processUsbStreamLine: ligne vide apr\xe8s trim");return}if(s.Z.debug("processUsbStreamLine:",r.substring(0,Math.min(100,r.length))),Y(r),r.startsWith("{"))try{var t,a,i,n,l,o,u,c,d,g,m,b,f,v,w,_,p,D,P,M,I,E,U,T,A,q,O,N,j,J,F,H,G;let e=JSON.parse(r);(!e.seq||e.seq<=5)&&s.Z.log("\uD83D\uDCE5 JSON:",{seq:e.seq||0,iccid:null===(t=e.sim_iccid)||void 0===t?void 0:t.slice(-10),serial:e.device_serial,flow:e.flow_lpm,battery:e.battery_percent}),"usb_stream"!==e.mode&&"usb_stream"!==e.type&&("USB_STREAM"!==e.status||null==e.flow_lpm)&&(null==e.flow_lpm||null==e.battery_percent||e.type)||s.Z.log("\uD83D\uDCCA Donn\xe9es usb_stream re\xe7ues:",{seq:e.seq,flow_lpm:e.flow_lpm,flowrate:e.flowrate,flow:e.flow,battery_percent:e.battery_percent,battery:e.battery,rssi:e.rssi,latitude:e.latitude,longitude:e.longitude,hasGPS:!!(e.latitude&&e.longitude),mode:e.mode,type:e.type,status:e.status});let Y="usb_stream"===e.mode||"usb_stream"===e.type||"USB_STREAM"===e.status;if("device_info"===e.type&&!Y){let r=new Date().toISOString(),t={sim_iccid:e.iccid||null,device_serial:e.serial||null,firmware_version:e.firmware_version||null,device_name:e.device_name||null,last_seen:r};B(e=>({...e,sim_iccid:t.sim_iccid||(null==e?void 0:e.sim_iccid)||null,device_serial:t.device_serial||(null==e?void 0:e.device_serial)||null,firmware_version:t.firmware_version||(null==e?void 0:e.firmware_version)||null,device_name:t.device_name||(null==e?void 0:e.device_name)||null,last_battery:(null==e?void 0:e.last_battery)||null,latitude:(null==e?void 0:e.latitude)||null,longitude:(null==e?void 0:e.longitude)||null,rssi:(null==e?void 0:e.rssi)||null,last_seen:r}));let n={id:"usb_info_".concat(Date.now()),device_name:e.device_name||"USB-".concat((null===(a=e.iccid)||void 0===a?void 0:a.slice(-4))||(null===(i=e.serial)||void 0===i?void 0:i.slice(-4))||"XXXX"),sim_iccid:e.iccid||null,device_serial:e.serial||null,firmware_version:e.firmware_version||null,status:"usb_connected",last_seen:r,isVirtual:!0,fromUsbInfo:!0};if(h||y?h?S(e=>({...e,...n,firmware_version:n.firmware_version||e.firmware_version,last_seen:r})):y&&Z(e=>({...e,...n,firmware_version:n.firmware_version||e.firmware_version,last_seen:r})):Z(n),W.current){let t=e.iccid||e.serial||e.device_name;if(t){let a=e.firmware_version||"";W.current(t,a,{last_seen:r,status:"usb_connected"}),s.Z.debug("\uD83D\uDD04 Mise \xe0 jour base de donn\xe9es (device_info):",{identifier:t,firmwareVersion:a||"(non disponible)",last_seen:r})}else s.Z.debug("⚠️ Aucun identifiant disponible dans device_info pour mise \xe0 jour base de donn\xe9es")}else s.Z.debug("⚠️ Callback updateDeviceFirmwareRef non disponible pour device_info");return}if("device_config"===e.type&&!Y){let r={sleep_minutes:null!==(n=e.sleep_minutes)&&void 0!==n?n:null,measurement_duration_ms:null!==(l=e.measurement_duration_ms)&&void 0!==l?l:null,calibration_coefficients:e.calibration_coefficients?Array.isArray(e.calibration_coefficients)?e.calibration_coefficients:[e.calibration_coefficients[0]||0,e.calibration_coefficients[1]||1,e.calibration_coefficients[2]||0]:[0,1,0]};B(e=>({...e,config:r})),s.Z.log("✅ Configuration USB stock\xe9e:",{sleep_minutes:r.sleep_minutes,measurement_duration_ms:r.measurement_duration_ms,calibration:r.calibration_coefficients}),window.dispatchEvent(new CustomEvent("usb-device-config-received",{detail:r}));return}if(Y){let r=new Date().toISOString();(!e.seq||e.seq<=3)&&s.Z.log("✅ Format unifi\xe9 d\xe9tect\xe9:",{seq:e.seq,mode:e.mode,type:e.type,has_sim_iccid:!!e.sim_iccid,has_device_name:!!e.device_name,has_firmware_version:!!e.firmware_version,has_flow_lpm:null!=e.flow_lpm,has_battery:null!=e.battery_percent});{s.Z.log("\uD83D\uDD0D\uD83D\uDD0D\uD83D\uDD0D [USB] PAYLOAD RE\xc7U:",{type:e.type,mode:e.mode,sim_iccid:e.sim_iccid,device_serial:e.device_serial,device_name:e.device_name,firmware_version:e.firmware_version,allKeys:Object.keys(e)});let t={sim_iccid:e.sim_iccid||null,device_serial:e.device_serial||null,firmware_version:e.firmware_version||null,device_name:e.device_name||null,last_seen:r};B(e=>{var a;let i={...e,sim_iccid:t.sim_iccid||(null==e?void 0:e.sim_iccid)||null,device_serial:t.device_serial||(null==e?void 0:e.device_serial)||null,firmware_version:t.firmware_version||(null==e?void 0:e.firmware_version)||null,device_name:t.device_name||(null==e?void 0:e.device_name)||null,last_seen:r};return s.Z.log("\uD83D\uDCDD [USB] Device Info:",{iccid:null===(a=i.sim_iccid)||void 0===a?void 0:a.slice(-10),serial:i.device_serial,name:i.device_name}),(i.sim_iccid||i.device_serial)&&(i.sim_iccid!==(null==e?void 0:e.sim_iccid)||i.device_serial!==(null==e?void 0:e.device_serial))&&s.Z.log("\uD83D\uDCDD [USB] ✅ Mise \xe0 jour usbDeviceInfo avec NOUVEAUX identifiants:",{sim_iccid:i.sim_iccid,device_serial:i.device_serial,device_name:i.device_name,firmware_version:i.firmware_version}),i});let a={id:"usb_info_".concat(Date.now()),device_name:e.device_name||"USB-".concat((null===(o=e.sim_iccid)||void 0===o?void 0:o.slice(-4))||(null===(u=e.device_serial)||void 0===u?void 0:u.slice(-4))||"XXXX"),sim_iccid:e.sim_iccid||null,device_serial:e.device_serial||null,firmware_version:e.firmware_version||null,status:"usb_connected",last_seen:r,isVirtual:!0,fromUsbInfo:!0};if(h||y?h?S(e=>({...e,...a,firmware_version:a.firmware_version||e.firmware_version,last_seen:r})):y&&Z(e=>({...e,...a,firmware_version:a.firmware_version||e.firmware_version,last_seen:r})):Z(a),W.current){let t=e.sim_iccid||e.device_serial||e.device_name;if(t){let a=e.firmware_version||"";W.current(t,a,{last_seen:r,status:"usb_connected"})}}}if(null!=e.sleep_minutes||null!=e.measurement_duration_ms||e.calibration_coefficients){let r={sleep_minutes:null!==(c=e.sleep_minutes)&&void 0!==c?c:null,measurement_duration_ms:null!==(d=e.measurement_duration_ms)&&void 0!==d?d:null,calibration_coefficients:e.calibration_coefficients?Array.isArray(e.calibration_coefficients)?e.calibration_coefficients:[e.calibration_coefficients[0]||0,e.calibration_coefficients[1]||1,e.calibration_coefficients[2]||0]:[0,1,0]};s.Z.log("✅ Configuration extraite du format unifi\xe9:",r),B(e=>({...e,config:r})),s.Z.log("\uD83D\uDCE2 \xc9mission \xe9v\xe9nement usb-device-config-received"),window.dispatchEvent(new CustomEvent("usb-device-config-received",{detail:r}))}else s.Z.debug("⚠️ Format unifi\xe9 sans configuration (sleep_minutes, measurement_duration_ms, calibration_coefficients tous null/undefined)");{let t={id:"usb-".concat(null!==(g=e.seq)&&void 0!==g?g:Date.now()),seq:null!==(m=e.seq)&&void 0!==m?m:null,timestamp:Date.now(),flowrate:null!==(v=null!==(f=null!==(b=e.flow_lpm)&&void 0!==b?b:e.flowrate)&&void 0!==f?f:e.flow)&&void 0!==v?v:null,battery:null!==(_=null!==(w=e.battery_percent)&&void 0!==w?w:e.battery)&&void 0!==_?_:null,rssi:null!==(p=e.rssi)&&void 0!==p?p:null,latitude:null!==(D=e.latitude)&&void 0!==D?D:null,longitude:null!==(P=e.longitude)&&void 0!==P?P:null,interval:null!==(I=null!==(M=e.interval_ms)&&void 0!==M?M:e.interval)&&void 0!==I?I:null,raw:{...e,firmware_version:e.firmware_version||null}};(!e.seq||e.seq<=3)&&s.Z.log("\uD83D\uDCCA Mesure USB #"+(e.seq||"?")+":",{flowrate:t.flowrate,battery:t.battery,rssi:t.rssi,gps:t.latitude&&t.longitude?"".concat(t.latitude.toFixed(4),", ").concat(t.longitude.toFixed(4)):"N/A"}),R(e=>[...e,t].slice(-120)),L(t),V(Date.now()),x(null),k("running"),z.current&&z.current.isMaster&&z.current.notifyDataReceived({measurement:t,deviceInfo:C,timestamp:Date.now()}),B(e=>({...e,flowrate:null!==t.flowrate&&void 0!==t.flowrate?t.flowrate:(null==e?void 0:e.flowrate)||null,last_battery:null!==t.battery&&void 0!==t.battery?t.battery:(null==e?void 0:e.last_battery)||null,latitude:null!==t.latitude&&void 0!==t.latitude?t.latitude:(null==e?void 0:e.latitude)||null,longitude:null!==t.longitude&&void 0!==t.longitude?t.longitude:(null==e?void 0:e.longitude)||null,rssi:null!==t.rssi&&void 0!==t.rssi&&-999!==t.rssi?t.rssi:(null==e?void 0:e.rssi)||null,last_seen:r}));let a=h||y;if(s.Z.log("\uD83D\uDD0D [USB-CONTEXT] Check envoi mesure:",{hasCurrentDevice:!!a,currentDevice:a?a.device_name:"AUCUN",usbConnectedDevice:h?h.device_name:"null",usbVirtualDevice:y?y.device_name:"null",hasCallback:!!X.current}),a&&(s.Z.log("\uD83D\uDCE4 [USB-CONTEXT] Appel sendMeasurementToApi..."),ee(t,a),W.current)){let e=a.sim_iccid||a.device_serial||a.device_name;e&&W.current(e,null,{last_seen:r,status:"usb_connected",last_battery:null!==t.battery&&void 0!==t.battery?t.battery:void 0,last_flowrate:null!==t.flowrate&&void 0!==t.flowrate?t.flowrate:void 0,last_rssi:null!==t.rssi&&void 0!==t.rssi&&-999!==t.rssi?t.rssi:void 0})}}return}if("usb_stream"===e.mode||"usb_stream"===e.type||"USB_STREAM"===e.status&&null!=e.flow_lpm||null!=e.flow_lpm&&null!=e.battery_percent&&!e.type){let r={id:"usb-".concat(null!==(E=e.seq)&&void 0!==E?E:Date.now()),seq:null!==(U=e.seq)&&void 0!==U?U:null,timestamp:Date.now(),flowrate:null!==(q=null!==(A=null!==(T=e.flow_lpm)&&void 0!==T?T:e.flowrate)&&void 0!==A?A:e.flow)&&void 0!==q?q:null,battery:null!==(N=null!==(O=e.battery_percent)&&void 0!==O?O:e.battery)&&void 0!==N?N:null,rssi:null!==(j=e.rssi)&&void 0!==j?j:null,latitude:null!==(J=e.latitude)&&void 0!==J?J:null,longitude:null!==(F=e.longitude)&&void 0!==F?F:null,interval:null!==(G=null!==(H=e.interval_ms)&&void 0!==H?H:e.interval)&&void 0!==G?G:null,raw:{...e,firmware_version:e.firmware_version||null}};(!e.seq||e.seq<=3)&&s.Z.log("\uD83D\uDCCA Mesure USB #"+(e.seq||"?")+":",{flowrate:r.flowrate,battery:r.battery,rssi:r.rssi,gps:r.latitude&&r.longitude?"".concat(r.latitude.toFixed(4),", ").concat(r.longitude.toFixed(4)):"N/A"}),R(e=>[...e,r].slice(-120)),L(r),V(Date.now()),x(null),k("running"),z.current&&z.current.isMaster&&z.current.notifyDataReceived({measurement:r,deviceInfo:C,timestamp:Date.now()});let t=new Date().toISOString();B(a=>({...a,sim_iccid:(null==a?void 0:a.sim_iccid)||null,device_serial:(null==a?void 0:a.device_serial)||null,firmware_version:e.firmware_version||(null==a?void 0:a.firmware_version)||null,flowrate:null!==r.flowrate&&void 0!==r.flowrate?r.flowrate:(null==a?void 0:a.flowrate)||null,last_battery:null!==r.battery&&void 0!==r.battery?r.battery:(null==a?void 0:a.last_battery)||null,latitude:null!==r.latitude&&void 0!==r.latitude?r.latitude:(null==a?void 0:a.latitude)||null,longitude:null!==r.longitude&&void 0!==r.longitude?r.longitude:(null==a?void 0:a.longitude)||null,rssi:null!==r.rssi&&void 0!==r.rssi&&-999!==r.rssi?r.rssi:(null==a?void 0:a.rssi)||null,last_seen:t}));let a=h||y;if(s.Z.log("\uD83D\uDD0D [USB-CONTEXT-OLD] Check envoi mesure:",{hasCurrentDevice:!!a,currentDevice:a?a.device_name:"AUCUN",hasCallback:!!X.current}),a){if(s.Z.log("\uD83D\uDCE4 [USB-CONTEXT-OLD] Appel sendMeasurementToApi..."),ee(r,a),W.current){let i=(null==C?void 0:C.sim_iccid)||(null==C?void 0:C.device_serial)||a.sim_iccid||a.device_serial||a.device_name;if(i){let n=e.firmware_version||(null==C?void 0:C.firmware_version)||a.firmware_version,l={last_seen:t,status:"usb_connected"};null!==r.battery&&void 0!==r.battery&&(l.last_battery=r.battery),null!==r.flowrate&&void 0!==r.flowrate&&(l.last_flowrate=r.flowrate),null!==r.rssi&&void 0!==r.rssi&&-999!==r.rssi&&(l.last_rssi=r.rssi),W.current(i,n||"",l),s.Z.debug("\uD83D\uDD04 Mise \xe0 jour base de donn\xe9es demand\xe9e:",{identifier:i,firmwareVersion:n||"(non disponible)",battery:null!==r.battery&&void 0!==r.battery?r.battery:"(non disponible)",last_seen:t})}else s.Z.debug("⚠️ Aucun identifiant disponible pour mise \xe0 jour base de donn\xe9es")}else s.Z.debug("⚠️ Callback updateDeviceFirmwareRef non disponible")}else s.Z.debug("⚠️ Aucun dispositif USB connect\xe9 pour mise \xe0 jour");return}}catch(e){s.Z.debug("JSON invalide:",r,e);return}},[Y,ee,h,y,C]),et=(0,i.useCallback)(e=>{var r;if(!e)return;H.current+=e;let t=H.current.split(/\r?\n/);if(H.current=null!==(r=t.pop())&&void 0!==r?r:"",0===t.length&&H.current.length>0){let e=H.current.trim();if(e.startsWith("{")&&e.endsWith("}"))try{JSON.parse(e),er(e),H.current="";return}catch(e){}}let a=0;t.forEach(e=>{if(e||""===e){let r=e.trim();if(r.startsWith("{")){a++;try{let e=JSON.parse(r);s.Z.log("\uD83D\uDCE5 JSON #".concat(a," - type: ").concat(e.type||e.mode||"unknown",", seq: ").concat(e.seq||"N/A")),(null!=e.sleep_minutes||null!=e.measurement_duration_ms||e.calibration_coefficients)&&s.Z.log("✅ Configuration d\xe9tect\xe9e dans JSON:",{sleep_minutes:e.sleep_minutes,measurement_duration_ms:e.measurement_duration_ms,calibration:e.calibration_coefficients})}catch(e){s.Z.warn("❌ JSON invalide:",e.message,"| Ligne: ".concat(r.substring(0,100)))}}er(e)}}),t.length>0&&0===a&&s.Z.debug("\uD83D\uDCE5 ".concat(t.length," ligne(s) de log du firmware trait\xe9e(s)")),"waiting"===T&&(s.Z.log("✅ Premier chunk re\xe7u, passage \xe0 running"),k("running"))},[er,T]),ea=(0,i.useCallback)(async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;try{x(null);let r="paused"===T;r?s.Z.log("▶️ [USB] Reprise du streaming USB depuis la pause..."):s.Z.debug("[USB] Starting stream"),k("connecting");let t=e||c,a=t&&t.readable&&t.writable,i=t&&d;if(a||i)s.Z.debug("[USB] Port ready"),t&&t!==c&&s.Z.log("\uD83D\uDD04 [USB] Mise \xe0 jour du port dans le contexte...");else if(!t||a||i)throw s.Z.error("❌ [USB] Aucun port USB connect\xe9"),Error("Aucun port USB connect\xe9. Veuillez s\xe9lectionner et connecter un port d'abord.");else{if(s.Z.log("\uD83D\uDD04 [USB] Port existe mais non ouvert, reconnexion..."),!await b(t,115200))throw Error("Impossible de reconnecter au port");s.Z.log("✅ [USB] Port reconnect\xe9")}if(F.current&&!r){s.Z.debug("[USB] Stop ancien stream");try{F.current()}catch(e){s.Z.warn("⚠️ [USB] Erreur lors de l'arr\xeat de l'ancien streaming:",e)}F.current=null,await new Promise(e=>setTimeout(e,300))}r?(H.current="",Y("▶️ Reprise du streaming...","dashboard")):(H.current="",R([]),O([]),L(null),V(null)),s.Z.debug("[USB] Reading...");let n=await v(et);if(!n||"function"!=typeof n)throw Error("startReading n'a pas retourn\xe9 de fonction stop valide");F.current=n,k("waiting"),s.Z.log("✅ USB streaming d\xe9marr\xe9")}catch(r){s.Z.error("❌ [USB] Erreur d\xe9marrage streaming:",r);let e=r.message||"Impossible de d\xe9marrer le streaming USB";x(e),k("idle"),Y("❌ Erreur: ".concat(e),"dashboard")}},[Q,et,v,Y,s.Z,c,d,w,T]),ei=(0,i.useCallback)(function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(F.current){try{e||s.Z.debug("[USB] Pause"),F.current(),e||s.Z.log("✅ [USB] Fonction stop ex\xe9cut\xe9e")}catch(e){s.Z.warn("⚠️ [USB] Erreur lors de l'arr\xeat du streaming:",e)}F.current=null}else e||s.Z.log("ℹ️ [USB] Aucun streaming actif \xe0 arr\xeater")},[]),en=(0,i.useCallback)(()=>{s.Z.log("⏸️ [USB] Pause du streaming demand\xe9e"),ei(!0),k("paused"),x(null),Y("⏸️ Streaming en pause - Les logs sont conserv\xe9s","dashboard"),s.Z.log("✅ [USB] Streaming en pause, port toujours connect\xe9")},[ei,Y]),el=(0,i.useCallback)(()=>{s.Z.debug("[USB] Stop streaming"),ei(!0),H.current="",R([]),O([]),L(null),V(null),k("idle"),s.Z.debug("[USB] Streaming stopped")},[ei]),es=(0,i.useCallback)(async function(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0],arguments.length>1&&arguments[1],arguments.length>2&&arguments[2],arguments.length>3&&arguments[3],arguments.length>4&&arguments[4],!g)return s.Z.warn("Web Serial API non support\xe9"),null;U(!0);try{return null}catch(e){return s.Z.error("Erreur d\xe9tection USB:",e),null}finally{U(!1)}},[g]);(0,i.useEffect)(()=>{if(!g){I(!1);return}if(d&&c)return;let e=!0,r=!1,t=async()=>{if(!r&&(!d||!c)){r=!0;try{let t=await navigator.serial.getPorts();if(0===t.length){r=!1;return}for(let a of t)if(c!==a||!d){if(a.readable&&a.writable){if(a.writable.locked||a.readable.locked){s.Z.debug("\uD83D\uDD0C [USB] Port d\xe9j\xe0 ouvert et verrouill\xe9 par un autre onglet, \xe9coute des donn\xe9es partag\xe9es..."),r=!1;return}s.Z.log("\uD83D\uDD0C [USB] Port d\xe9j\xe0 ouvert d\xe9tect\xe9, connexion automatique...");try{if(await b(a,115200)&&e){s.Z.log("✅ [USB] Connexion automatique r\xe9ussie"),Y("✅ Connexion automatique au dispositif USB \xe9tablie","dashboard"),setTimeout(async()=>{if(e&&!F.current)try{s.Z.log("\uD83D\uDCE1 [USB] D\xe9marrage automatique du streaming..."),await ea(a)}catch(e){s.Z.warn("⚠️ [USB] Erreur d\xe9marrage streaming automatique:",e)}},500),r=!1;return}}catch(e){s.Z.debug("⚠️ [USB] Erreur connexion port d\xe9j\xe0 ouvert:",e.message);continue}}else{s.Z.debug("[USB] Auto-connect");try{if(await b(a,115200)&&e){s.Z.log("✅ [USB] Connexion automatique r\xe9ussie"),Y("✅ Connexion automatique au dispositif USB \xe9tablie","dashboard"),setTimeout(async()=>{if(e&&!F.current)try{s.Z.log("\uD83D\uDCE1 [USB] D\xe9marrage automatique du streaming..."),await ea(a)}catch(e){s.Z.warn("⚠️ [USB] Erreur d\xe9marrage streaming automatique:",e)}},500),r=!1;return}}catch(e){s.Z.debug("⚠️ [USB] Erreur connexion port:",e.message);continue}}}r=!1}catch(e){s.Z.debug("⚠️ [USB] Erreur d\xe9tection/connexion automatique:",e.message),r=!1}}};t();let a=setInterval(()=>{e&&!d&&t()},3e3);return()=>{e=!1,clearInterval(a)}},[g,d,c,b,ea,Y]),(0,i.useEffect)(()=>()=>{el()},[el]);let eo=(0,i.useCallback)(e=>{X.current=e},[]),eu=(0,i.useCallback)(e=>{W.current=e},[]),ec=(0,i.useCallback)(async(e,r,a)=>{if(!e)return s.Z.warn("autoCreateOrUpdateDevice: deviceInfo vide"),null;let i=e.sim_iccid||e.device_serial;if(!i)return s.Z.warn("autoCreateOrUpdateDevice: aucun identifiant (ICCID ou serial)",e),null;try{s.Z.log("\uD83D\uDD0D [AUTO-CREATE] V\xe9rification dispositif: ".concat(i));let{fetchJson:n}=await t.e(2617).then(t.bind(t,2617)),l=await n(r,a,"/api.php/devices",{},{requiresAuth:!0});if(!l.success)return s.Z.error("❌ \xc9chec r\xe9cup\xe9ration dispositifs:",l.message),null;let o=(l.devices||[]).find(r=>e.sim_iccid&&r.sim_iccid===e.sim_iccid||e.device_serial&&r.device_serial===e.device_serial);if(o){s.Z.log("✅ [AUTO-CREATE] Dispositif trouv\xe9 (ID: ".concat(o.id,"), mise \xe0 jour..."));let t={last_seen:new Date().toISOString(),status:"usb_connected"};e.firmware_version&&(t.firmware_version=e.firmware_version),e.sim_iccid&&!o.sim_iccid&&(t.sim_iccid=e.sim_iccid),e.device_serial&&!o.device_serial&&(t.device_serial=e.device_serial);let i=await n(r,a,"/api.php/devices/".concat(o.id),{method:"PATCH",body:JSON.stringify(t)},{requiresAuth:!0});if(i.success)return s.Z.log("✅ [AUTO-CREATE] Dispositif mis \xe0 jour avec succ\xe8s"),{...o,...t};return s.Z.error("❌ [AUTO-CREATE] \xc9chec mise \xe0 jour:",i.message),o}{s.Z.log("\uD83C\uDD95 [AUTO-CREATE] Nouveau dispositif d\xe9tect\xe9, cr\xe9ation automatique...");let t={device_name:e.device_name||"USB-".concat(i.slice(-4)),sim_iccid:e.sim_iccid||null,device_serial:e.device_serial||null,firmware_version:e.firmware_version||null,status:"usb_connected",last_seen:new Date().toISOString()},l=await n(r,a,"/api.php/devices",{method:"POST",body:JSON.stringify(t)},{requiresAuth:!0});if(l.success)return s.Z.log("✅ [AUTO-CREATE] Nouveau dispositif cr\xe9\xe9 avec succ\xe8s:",l.device),l.device;return s.Z.error("❌ [AUTO-CREATE] \xc9chec cr\xe9ation:",l.message),null}}catch(e){return s.Z.error("❌ [AUTO-CREATE] Erreur:",e),null}},[]),ed=(0,i.useRef)(ec);return(0,i.useEffect)(()=>{ed.current=ec},[ec]),(0,a.jsx)(u.Provider,{value:{usbConnectedDevice:h,setUsbConnectedDevice:S,usbVirtualDevice:y,setUsbVirtualDevice:Z,usbDeviceInfo:C,usbPortInfo:D,setUsbPortInfo:P,autoDetecting:M,setAutoDetecting:I,checkingUSB:E,setCheckingUSB:U,isConnected:d,isSupported:g,port:c,usbStreamStatus:T,usbStreamMeasurements:A,usbStreamLogs:q,usbStreamError:N,usbStreamLastMeasurement:j,usbStreamLastUpdate:J,startUsbStreaming:ea,pauseUsbStreaming:en,stopUsbStreaming:el,detectUSBDevice:es,ensurePortReady:Q,requestPort:m,connect:b,disconnect:f,startReading:v,write:w,appendUsbStreamLog:Y,clearUsbStreamLogs:K,setSendMeasurementCallback:eo,setUpdateDeviceFirmwareCallback:eu},children:r})}function d(){let e=(0,i.useContext)(u);if(!e)throw Error("useUsb must be used within UsbProvider");return e}},542:function(e,r,t){t.d(r,{DE:function(){return l},Yu:function(){return n}});let a=[{usbVendorId:6790,usbProductId:21972,manufacturer:"QinHeng/CH340",label:"OTT Module (CH340 USB-S\xe9rie)"}],i=e=>null==e?"????":e.toString(16).padStart(4,"0");function n(){return a.map(e=>({usbVendorId:e.usbVendorId,usbProductId:e.usbProductId}))}function l(e){if(!e)return null;let r=a.find(r=>r.usbVendorId===e.usbVendorId&&(!r.usbProductId||r.usbProductId===e.usbProductId));return r?r.label:e.usbVendorId||e.usbProductId?"USB ".concat(i(e.usbVendorId),":").concat(i(e.usbProductId)):null}},9629:function(e,r,t){t.d(r,{T:function(){return s}});let a=null;try{a=t(8828).Z||t(8828).k}catch(e){a={debug:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.debug(...r)},warn:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.warn(...r)},error:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.error(...r)},log:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.log(...r)}}}let i="ott-usb-port-state";class n{generateTabId(){return"tab-".concat(Date.now(),"-").concat(Math.random().toString(36).substr(2,9))}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{if(this.isMaster)this.broadcast({type:"heartbeat",tabId:this.tabId,timestamp:Date.now()}),this.updateStorage({masterTabId:this.tabId,lastHeartbeat:Date.now()});else{let e=this.getStorageState();e&&e.masterTabId&&Date.now()-(e.lastHeartbeat||0)>5e3&&(void 0!==a&&a.debug&&a.debug("[USB Sharing] Master timeout, becoming master"),this.becomeMaster())}},2e3)}stopHeartbeat(){this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null)}checkState(){let e=this.getStorageState();e&&e.masterTabId&&Date.now()-(e.lastHeartbeat||0)<5e3?(this.masterTabId=e.masterTabId,this.isMaster=!1,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:this.masterTabId})):this.becomeMaster()}becomeMaster(){this.isMaster=!0,this.masterTabId=this.tabId,this.updateStorage({masterTabId:this.tabId,lastHeartbeat:Date.now()}),this.broadcast({type:"master-announcement",tabId:this.tabId,timestamp:Date.now()}),this.notifyListeners("state-changed",{isMaster:!0,masterTabId:this.tabId}),void 0!==a&&a.debug&&a.debug("[USB Sharing] Became master tab")}requestMaster(){return this.broadcast({type:"request-master",tabId:this.tabId,timestamp:Date.now()}),new Promise(e=>{setTimeout(()=>{let r=this.getStorageState();r&&r.masterTabId===this.tabId?e(!0):e(!1)},500)})}broadcast(e){this.channel&&this.channel.postMessage({...e,tabId:this.tabId})}handleMessage(e){let{type:r,tabId:t,data:a}=e.data;if(t!==this.tabId)switch(r){case"heartbeat":this.isMaster&&t!==this.tabId?t<this.tabId&&(this.isMaster=!1,this.masterTabId=t,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:t})):this.isMaster||(this.masterTabId=t,this.lastHeartbeat=Date.now());break;case"master-announcement":case"master-response":this.isMaster||(this.masterTabId=t,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:t}));break;case"request-master":this.isMaster&&this.broadcast({type:"master-response",tabId:this.tabId,timestamp:Date.now()});break;case"port-opened":this.notifyListeners("port-opened",a);break;case"port-closed":this.notifyListeners("port-closed",a);break;case"data-received":this.notifyListeners("data-received",a)}}handleStorageChange(e){try{let r=JSON.parse(e||"{}");r.masterTabId&&r.masterTabId!==this.tabId&&(this.masterTabId=r.masterTabId,this.isMaster&&(this.isMaster=!1,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:r.masterTabId})))}catch(e){void 0!==a&&a.warn&&a.warn("[USB Sharing] Error parsing storage change:",e)}}getStorageState(){try{let e=localStorage.getItem(i);return e?JSON.parse(e):null}catch(e){return null}}updateStorage(e){try{localStorage.setItem(i,JSON.stringify({...e,timestamp:Date.now()}))}catch(e){void 0!==a&&a.warn&&a.warn("[USB Sharing] Error updating storage:",e)}}on(e,r){return this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(r),()=>{let t=this.listeners.get(e);if(t){let e=t.indexOf(r);e>-1&&t.splice(e,1)}}}notifyListeners(e,r){let t=this.listeners.get(e);t&&t.forEach(e=>{try{e(r)}catch(e){void 0!==a&&a.error&&a.error("[USB Sharing] Error in listener:",e)}})}notifyPortOpened(e){this.isMaster&&this.broadcast({type:"port-opened",data:e})}notifyPortClosed(){this.isMaster&&this.broadcast({type:"port-closed",data:{tabId:this.tabId}})}notifyDataReceived(e){this.isMaster&&this.broadcast({type:"data-received",data:e})}cleanup(){this.stopHeartbeat(),this.isMaster&&(localStorage.removeItem(i),this.broadcast({type:"master-closed",tabId:this.tabId})),this.channel&&this.channel.close()}constructor(){this.channel="undefined"!=typeof BroadcastChannel?new BroadcastChannel("ott-usb-port-sharing"):null,this.tabId=this.generateTabId(),this.isMaster=!1,this.masterTabId=null,this.heartbeatInterval=null,this.listeners=new Map,this.lastHeartbeat=Date.now(),this.channel&&(this.channel.onmessage=e=>this.handleMessage(e)),window.addEventListener("storage",e=>{e.key===i&&this.handleStorageChange(e.newValue)}),this.startHeartbeat(),this.checkState()}}let l=null;function s(){return l||(l=new n,window.addEventListener("beforeunload",()=>{l.cleanup()})),l}}}]);