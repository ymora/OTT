"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4767],{4807:function(e,r,t){t.d(r,{s:function(){return o}});var a=t(2265),n=t(542),i=t(8828),l=t(9629);function o(){let[e,r]=(0,a.useState)(null),[t,o]=(0,a.useState)(!1),[s,u]=(0,a.useState)([]),[c,d]=(0,a.useState)(null),g=(0,a.useRef)(null),m=(0,a.useRef)(null),b=(0,a.useRef)(null),f=(0,a.useRef)(!1),v=(0,a.useRef)(null),w="undefined"!=typeof navigator&&"serial"in navigator;(0,a.useEffect)(()=>{{b.current=(0,l.T)();let a=b.current.on("state-changed",async a=>{let n=f.current;if(f.current=a.isMaster,i.Z.debug("[SerialPortManager] State changed:",a),!a.isMaster&&n&&t&&e){i.Z.warn("[SerialPortManager] No longer master, closing port automatically...");try{if(g.current){try{await g.current.cancel(),await g.current.release()}catch(e){}g.current=null}if(m.current){try{await m.current.release()}catch(e){}m.current=null}if(e)try{await e.close()}catch(e){}o(!1),r(null),i.Z.debug("[SerialPortManager] Port closed after losing master status")}catch(e){i.Z.error("[SerialPortManager] Error closing port after losing master status:",e)}}}),n=b.current.on("data-received",e=>{f.current||(v.current=e,i.Z.debug("[SerialPortManager] Data received from master tab"))});return()=>{a(),n()}}},[t]);let _=(0,a.useCallback)(async()=>{if(!w)return d("Web Serial API non support\xe9 par ce navigateur. Utilisez Chrome ou Edge."),null;try{var e;d(null);let t=(0,n.Yu)(),a=t.length>0?{filters:t}:void 0,l=await navigator.serial.requestPort(a);r(l);let o=null==l?void 0:null===(e=l.getInfo)||void 0===e?void 0:e.call(l),s=(0,n.DE)(o);return s&&i.Z.log("[USB] Port s\xe9lectionn\xe9: ".concat(s)),l}catch(e){return"NotFoundError"!==e.name&&d("Erreur lors de la s\xe9lection du port: ".concat(e.message)),null}},[w]),p=(0,a.useCallback)(async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:115200,n=t||e;if(!n)return d("Aucun port s\xe9lectionn\xe9"),!1;if(b.current){let e=b.current;if(e.checkState(),e.isMaster)f.current=!0,i.Z.debug("[SerialPortManager] Already master, can open port");else{if(i.Z.debug("[SerialPortManager] Not master, requesting master status..."),!await e.requestMaster())return i.Z.warn("[SerialPortManager] Port already open in another tab, listening to shared data only"),o(!0),r(null),d(null),!0;f.current=!0,i.Z.debug("[SerialPortManager] Became master, can open port")}}else f.current=!0;try{if(d(null),m.current){try{await m.current.release()}catch(e){}m.current=null}if(g.current){try{await g.current.cancel(),await g.current.release()}catch(e){}g.current=null}if(n.readable&&n.writable){if(i.Z.debug("[SerialPortManager] connect: port d\xe9j\xe0 ouvert dans cet onglet, v\xe9rification des locks..."),i.Z.debug("[SerialPortManager] connect: writable.locked =",n.writable.locked),i.Z.debug("[SerialPortManager] connect: readable.locked =",n.readable.locked),n.writable.locked||n.readable.locked){if(b.current&&(b.current.checkState(),!b.current.isMaster)||!f.current)return i.Z.warn("[SerialPortManager] connect: port verrouill\xe9 mais on n'est pas master - un autre onglet a le port"),d(null),o(!0),r(null),!0;i.Z.warn("[SerialPortManager] connect: port verrouill\xe9, fermeture compl\xe8te n\xe9cessaire...");try{if(m.current){try{await m.current.release()}catch(e){i.Z.warn("[SerialPortManager] connect: erreur release writer:",e)}m.current=null}if(g.current){try{await g.current.cancel(),await g.current.release()}catch(e){i.Z.warn("[SerialPortManager] connect: erreur release reader:",e)}g.current=null}i.Z.debug("[SerialPortManager] connect: fermeture du port pour le rouvrir...");try{await n.close(),i.Z.debug("[SerialPortManager] connect: port ferm\xe9, attente 500ms..."),await new Promise(e=>setTimeout(e,500))}catch(e){i.Z.warn("[SerialPortManager] connect: erreur fermeture port:",e)}i.Z.debug("[SerialPortManager] connect: port sera rouvert apr\xe8s la fermeture")}catch(e){return i.Z.error("[SerialPortManager] connect: erreur nettoyage:",e),d("Erreur lors du nettoyage du port: ".concat(e.message)),!1}}else{i.Z.debug("[SerialPortManager] connect: port non verrouill\xe9, r\xe9utilisation...");try{i.Z.debug("[SerialPortManager] connect: cr\xe9ation du writer...");let e=n.writable.getWriter();m.current=e,i.Z.debug("[SerialPortManager] connect: cr\xe9ation du reader...");let t=n.readable.getReader();return g.current=t,o(!0),r(n),b.current&&f.current&&b.current.notifyPortOpened({baudRate:a,timestamp:Date.now()}),i.Z.debug("[SerialPortManager] connect: ✅ port r\xe9utilis\xe9 avec succ\xe8s"),!0}catch(e){return i.Z.error("[SerialPortManager] connect: erreur r\xe9utilisation port:",e),d("Erreur lors de la r\xe9utilisation du port: ".concat(e.message)),o(!1),!1}}}i.Z.debug("[SerialPortManager] connect: ouverture du port...");try{await n.open({baudRate:a}),i.Z.debug("[SerialPortManager] connect: port ouvert")}catch(e){if("InvalidStateError"===e.name&&n.readable&&n.writable){if(i.Z.debug("[SerialPortManager] connect: port d\xe9j\xe0 ouvert (InvalidStateError), r\xe9utilisation..."),n.writable.locked||n.readable.locked)return d("Port toujours verrouill\xe9 apr\xe8s nettoyage. Attendez quelques secondes et r\xe9essayez."),i.Z.error("[SerialPortManager] connect: port toujours verrouill\xe9 apr\xe8s nettoyage"),o(!1),!1}else throw e}i.Z.debug("[SerialPortManager] connect: cr\xe9ation du writer...");let e=n.writable.getWriter();m.current=e,i.Z.debug("[SerialPortManager] connect: writer cr\xe9\xe9"),i.Z.debug("[SerialPortManager] connect: cr\xe9ation du reader...");let t=n.readable.getReader();return g.current=t,i.Z.debug("[SerialPortManager] connect: reader cr\xe9\xe9"),o(!0),r(n),i.Z.debug("[SerialPortManager] connect: ✅ connexion r\xe9ussie"),!0}catch(e){if("InvalidStateError"===e.name&&n.readable&&n.writable)try{if(n.writable.locked||n.readable.locked)return d("Port d\xe9j\xe0 utilis\xe9 par une autre connexion. D\xe9connectez d'abord."),o(!1),!1;let e=n.writable.getWriter();m.current=e;let t=n.readable.getReader();return g.current=t,o(!0),r(n),!0}catch(e){return d("Erreur de connexion (port d\xe9j\xe0 ouvert): ".concat(e.message)),o(!1),!1}return d("Erreur de connexion: ".concat(e.message)),o(!1),!1}},[e]),S=(0,a.useCallback)(async()=>{i.Z.debug("[SerialPortManager] disconnect: d\xe9but");try{if(g.current){i.Z.debug("[SerialPortManager] disconnect: arr\xeat du reader...");try{await g.current.cancel()}catch(e){i.Z.warn("[SerialPortManager] disconnect: erreur cancel reader:",e)}try{await g.current.release()}catch(e){i.Z.warn("[SerialPortManager] disconnect: erreur release reader:",e)}g.current=null,i.Z.debug("[SerialPortManager] disconnect: reader lib\xe9r\xe9")}if(m.current){i.Z.debug("[SerialPortManager] disconnect: lib\xe9ration du writer...");try{await m.current.release()}catch(e){i.Z.warn("[SerialPortManager] disconnect: erreur release writer:",e)}m.current=null,i.Z.debug("[SerialPortManager] disconnect: writer lib\xe9r\xe9")}if(e){i.Z.debug("[SerialPortManager] disconnect: fermeture du port...");try{await e.close(),i.Z.debug("[SerialPortManager] disconnect: port ferm\xe9")}catch(e){i.Z.warn("[SerialPortManager] disconnect: erreur fermeture port:",e)}}o(!1),r(null),d(null),b.current&&f.current&&(b.current.notifyPortClosed(),f.current=!1,i.Z.debug("[SerialPortManager] Notified port sharing system (port closed)")),i.Z.debug("[SerialPortManager] disconnect: ✅ d\xe9connexion compl\xe8te")}catch(e){i.Z.error("[SerialPortManager] disconnect: ❌ erreur:",e),d("Erreur de d\xe9connexion: ".concat(e.message))}},[e]),h=(0,a.useCallback)(async r=>{let a=e&&e.readable&&e.writable,n=g.current;if(i.Z.debug("[SerialPortManager] startReading: v\xe9rifications..."),i.Z.debug("[SerialPortManager] startReading: isConnected =",t),i.Z.debug("[SerialPortManager] startReading: port existe =",!!e),i.Z.debug("[SerialPortManager] startReading: port.readable =",!!(null==e?void 0:e.readable)),i.Z.debug("[SerialPortManager] startReading: port.writable =",!!(null==e?void 0:e.writable)),i.Z.debug("[SerialPortManager] startReading: readerRef.current =",!!g.current),!a&&!n)return i.Z.error("[SerialPortManager] startReading: Port non disponible (port:",!!e,"readable:",!!(null==e?void 0:e.readable),"writable:",!!(null==e?void 0:e.writable),"reader:",!!g.current,")"),d("Port non disponible. Le port doit \xeatre connect\xe9 avant de d\xe9marrer la lecture."),()=>{};if(!g.current&&a){i.Z.debug("[SerialPortManager] startReading: cr\xe9ation du reader...");try{if(e.readable.locked)return i.Z.error("[SerialPortManager] startReading: readable est verrouill\xe9"),d("Port readable verrouill\xe9. D\xe9connectez et reconnectez."),()=>{};g.current=e.readable.getReader(),i.Z.debug("[SerialPortManager] startReading: reader cr\xe9\xe9")}catch(e){return i.Z.error("[SerialPortManager] startReading: erreur cr\xe9ation reader:",e),d("Erreur cr\xe9ation reader: ".concat(e.message)),()=>{}}}if(!g.current)return i.Z.error("[SerialPortManager] startReading: Reader non disponible apr\xe8s tentative de cr\xe9ation"),d("Reader non disponible. Le port doit \xeatre connect\xe9 avant de d\xe9marrer la lecture."),()=>{};let l=!0,o=!0,s=0;return(async()=>{try{for(i.Z.debug("[SerialPortManager] D\xe9marrage de la boucle de lecture...");l&&o;){if(!g.current){i.Z.warn("[SerialPortManager] Reader perdu, arr\xeat de la lecture");break}try{let{value:e,done:t}=await g.current.read();if(s=0,t){i.Z.debug("[SerialPortManager] Stream termin\xe9 (done=true)");break}if(e&&r){let t=new TextDecoder().decode(e);t&&t.length>0&&(i.Z.debug("[SerialPortManager] Donn\xe9es re\xe7ues: ".concat(t.length," caract\xe8res")),r(t))}}catch(r){var e;if("NetworkError"===r.name){i.Z.debug("[SerialPortManager] Erreur r\xe9seau (d\xe9connexion probable)");break}if("TypeError"===r.name&&r.message.includes("cancel")){i.Z.debug("[SerialPortManager] Lecture annul\xe9e");break}if("FramingError"===r.name||(null===(e=r.message)||void 0===e?void 0:e.includes("Framing"))){if(++s<=3){i.Z.debug("[SerialPortManager] Erreur de framing ignor\xe9e (".concat(s,"/3)")),await new Promise(e=>setTimeout(e,50));continue}if(4===s){i.Z.warn("[SerialPortManager] Erreurs de framing d\xe9tect\xe9es (continuation silencieuse...)"),await new Promise(e=>setTimeout(e,100));continue}if(s%100==0){i.Z.debug("[SerialPortManager] ".concat(s," erreurs de framing (continuation...)")),await new Promise(e=>setTimeout(e,100));continue}await new Promise(e=>setTimeout(e,100));continue}if(s++,1===s)i.Z.error("[SerialPortManager] Erreur lors de la lecture:",r);else if(s>=5){i.Z.error("[SerialPortManager] Trop d'erreurs cons\xe9cutives (".concat(s,"), arr\xeat de la lecture")),d("Erreur de lecture r\xe9p\xe9t\xe9e: ".concat(r.message));break}else i.Z.debug("[SerialPortManager] Erreur ".concat(s,"/").concat(5,":"),r.message);await new Promise(e=>setTimeout(e,100))}}i.Z.debug("[SerialPortManager] Boucle de lecture termin\xe9e")}catch(e){i.Z.error("[SerialPortManager] Erreur dans la boucle de lecture:",e),"NetworkError"!==e.name&&l&&d("Erreur de lecture: ".concat(e.message))}finally{o=!1}})().catch(e=>{i.Z.error("[SerialPortManager] Erreur non g\xe9r\xe9e dans readLoop:",e),o=!1}),()=>{i.Z.debug("[SerialPortManager] Arr\xeat de la lecture demand\xe9"),l=!1,o=!1}},[t,d]),y=(0,a.useCallback)(async r=>{var a,n;if(i.Z.debug("[SerialPortManager] write: appel\xe9 avec","string"==typeof r?r.length:"non-string","caract\xe8res"),i.Z.debug("[SerialPortManager] write: writerRef.current existe?",!!m.current),i.Z.debug("[SerialPortManager] write: port existe?",!!e),i.Z.debug("[SerialPortManager] write: port.writable existe?",!!(null==e?void 0:e.writable)),i.Z.debug("[SerialPortManager] write: port.writable.locked?",null==e?void 0:null===(a=e.writable)||void 0===a?void 0:a.locked),i.Z.debug("[SerialPortManager] write: isConnected?",t),"string"!=typeof r){let e="Les donn\xe9es doivent \xeatre une string";return d(e),i.Z.error("[SerialPortManager] write:",e,"type re\xe7u:",typeof r),!1}if(!m.current){if(i.Z.warn("[SerialPortManager] write: writerRef.current est null, tentative de cr\xe9ation..."),!e||!e.writable){let r="Port non connect\xe9 ou writer non disponible";return d(r),i.Z.error("[SerialPortManager] write:",r,"port:",!!e,"writable:",!!(null==e?void 0:e.writable)),!1}try{if(e.writable&&!e.writable.locked)i.Z.debug("[SerialPortManager] write: cr\xe9ation d'un nouveau writer..."),m.current=e.writable.getWriter(),i.Z.debug("[SerialPortManager] write: writer cr\xe9\xe9 avec succ\xe8s");else{let r="Port writable verrouill\xe9 ou non disponible";return d(r),i.Z.error("[SerialPortManager] write:",r,"locked:",null===(n=e.writable)||void 0===n?void 0:n.locked),!1}}catch(r){let e="Erreur cr\xe9ation writer: ".concat(r.message);return d(e),i.Z.error("[SerialPortManager] write:",e,r),!1}}try{let e=new TextEncoder().encode(r);return i.Z.debug("[SerialPortManager] write: envoi de",e.length,"bytes via writerRef.current"),i.Z.debug("[SerialPortManager] write: contenu (hex):",Array.from(e).map(e=>e.toString(16).padStart(2,"0")).join(" ")),i.Z.debug("[SerialPortManager] write: contenu (ascii):",r.replace(/\n/g,"\\n").replace(/\r/g,"\\r")),await m.current.write(e),i.Z.debug("[SerialPortManager] write: ✅ donn\xe9es envoy\xe9es avec succ\xe8s"),!0}catch(e){if(d("Erreur d'\xe9criture: ".concat(e.message)),i.Z.error("[SerialPortManager] write: ❌ erreur lors de l'\xe9criture:",e),"NetworkError"===e.name||e.message.includes("writer")){i.Z.warn("[SerialPortManager] write: r\xe9initialisation du writer apr\xe8s erreur");try{await m.current.release()}catch(e){i.Z.warn("[SerialPortManager] write: erreur release writer:",e)}m.current=null}return!1}},[e,t]);return(0,a.useEffect)(()=>()=>{t&&S()},[t,S]),{port:e,isConnected:t,isSupported:w,error:c,requestPort:_,connect:p,disconnect:S,startReading:h,write:y}}},4767:function(e,r,t){t.d(r,{d:function(){return u},l:function(){return c}});var a=t(7437),n=t(2265),i=t(4807),l=t(8828),o=t(9629);let s=(0,n.createContext)();function u(e){let{children:r}=e,{port:u,isConnected:c,isSupported:d,requestPort:g,connect:m,disconnect:b,startReading:f,write:v}=(0,i.s)(),[w,_]=(0,n.useState)(null),[p,S]=(0,n.useState)(null),[h,y]=(0,n.useState)(null),[Z,D]=(0,n.useState)(!0),[M,P]=(0,n.useState)(!1),[I,E]=(0,n.useState)(null),[U,B]=(0,n.useState)("idle"),[C,k]=(0,n.useState)([]),[T,q]=(0,n.useState)([]),[R,A]=(0,n.useState)(null),[x,N]=(0,n.useState)(null),[O,L]=(0,n.useState)(null),j=(0,n.useRef)(null),V=(0,n.useRef)(""),H=(0,n.useRef)(null),F=(0,n.useRef)(null),J=(0,n.useRef)(null);(0,n.useEffect)(()=>{{J.current=(0,o.T)();let e=J.current.on("data-received",e=>{l.Z.debug("[UsbContext] Data received from master tab:",e),e.measurement&&(N(e.measurement),L(Date.now()),k(r=>[...r,e.measurement].slice(-120))),e.deviceInfo&&E(e.deviceInfo)});return()=>{e()}}},[]);let W=(0,n.useCallback)(function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"device";e&&q(t=>[...t,{id:"".concat(Date.now(),"-").concat(Math.random()),line:e,timestamp:Date.now(),source:r}].slice(-80))},[]),X=(0,n.useCallback)(async()=>{if(!d)throw Error("Web Serial API non support\xe9e par ce navigateur");if(u&&c||u&&!c&&await m(u,115200))return u;let e=await g();if(!e)throw Error("Aucun port USB s\xe9lectionn\xe9");if(!await m(e,115200))throw Error("Impossible de se connecter au port USB s\xe9lectionn\xe9");return e},[m,c,d,u,g]),z=(0,n.useCallback)(async(e,r)=>{if(!r||!H.current){l.Z.debug("⚠️ Pas de dispositif ou callback pour envoyer la mesure USB");return}try{var a,n,i,o,s;let u=r.sim_iccid;if((!u||"N/A"===u||u.length<10)&&(u=r.device_serial,l.Z.debug("\uD83D\uDCDD Utilisation device_serial comme ICCID:",u)),!u||"N/A"===u){let e=null===(n=r.device_name)||void 0===n?void 0:n.match(/USB-([a-f0-9:]+)/i);e&&e[1]?(u=e[1],l.Z.debug("\uD83D\uDCDD Utilisation device_name comme ICCID:",u)):u=r.device_name}if(!u||"N/A"===u){l.Z.warn("❌ Impossible d'envoyer la mesure USB: pas d'identifiant disponible",{device_name:r.device_name,sim_iccid:r.sim_iccid,device_serial:r.device_serial});return}let c=(null===(a=e.raw)||void 0===a?void 0:a.firmware_version)||r.firmware_version||null,d={sim_iccid:String(u).trim(),flowrate:null!==(i=e.flowrate)&&void 0!==i?i:0,battery:null!==(o=e.battery)&&void 0!==o?o:null,rssi:null!==(s=e.rssi)&&void 0!==s?s:null,firmware_version:c,timestamp:new Date(e.timestamp).toISOString(),status:"USB"};l.Z.debug("\uD83D\uDCE4 Envoi mesure USB \xe0 l'API:",d);let{sendMeasurementWithRetry:g}=await t.e(7546).then(t.bind(t,7546)),m=await g(d,H.current);m.success?l.Z.debug("✅ Mesure USB envoy\xe9e avec succ\xe8s"):m.queued?l.Z.info("\uD83D\uDCE6 Mesure USB mise en queue pour retry ult\xe9rieur"):l.Z.warn("⚠️ \xc9chec envoi mesure USB:",m.error)}catch(e){l.Z.error("❌ Erreur envoi mesure USB \xe0 l'API:",e,{device:r})}},[]),Y=(0,n.useCallback)(e=>{if(!e){l.Z.debug("processUsbStreamLine: ligne vide");return}let r=e.trim();if(!r){l.Z.debug("processUsbStreamLine: ligne vide apr\xe8s trim");return}if(l.Z.debug("processUsbStreamLine:",r.substring(0,Math.min(100,r.length))),W(r),r.startsWith("{"))try{var t,a,n,i,o,s,u,c,d,g,m,b,f,v,h,y,Z,D,M,P,U,C,T,q,R,x,O,j,V,H,X,Y;let e=JSON.parse(r);(!e.seq||e.seq<=3||"device_info"===e.type||"device_config"===e.type)&&l.Z.log("\uD83D\uDCE5 JSON re\xe7u:",{type:e.type||e.mode||"unknown",has_mode:!!e.mode,has_type:!!e.type,keys:Object.keys(e).slice(0,10),seq:e.seq,flow_lpm:e.flow_lpm,battery_percent:e.battery_percent,has_flow_lpm:void 0!==e.flow_lpm,has_battery_percent:void 0!==e.battery_percent}),"usb_stream"!==e.mode&&"usb_stream"!==e.type&&("USB_STREAM"!==e.status||null==e.flow_lpm)&&(null==e.flow_lpm||null==e.battery_percent||e.type)||l.Z.log("\uD83D\uDCCA Donn\xe9es usb_stream re\xe7ues:",{seq:e.seq,flow_lpm:e.flow_lpm,flowrate:e.flowrate,flow:e.flow,battery_percent:e.battery_percent,battery:e.battery,rssi:e.rssi,latitude:e.latitude,longitude:e.longitude,hasGPS:!!(e.latitude&&e.longitude),mode:e.mode,type:e.type,status:e.status});let W="usb_stream"===e.mode||"usb_stream"===e.type||"USB_STREAM"===e.status;if("device_info"===e.type&&!W){let r=new Date().toISOString(),n={sim_iccid:e.iccid||null,device_serial:e.serial||null,firmware_version:e.firmware_version||null,device_name:e.device_name||null,last_seen:r};E(e=>({...e,sim_iccid:n.sim_iccid||(null==e?void 0:e.sim_iccid)||null,device_serial:n.device_serial||(null==e?void 0:e.device_serial)||null,firmware_version:n.firmware_version||(null==e?void 0:e.firmware_version)||null,device_name:n.device_name||(null==e?void 0:e.device_name)||null,last_battery:(null==e?void 0:e.last_battery)||null,latitude:(null==e?void 0:e.latitude)||null,longitude:(null==e?void 0:e.longitude)||null,rssi:(null==e?void 0:e.rssi)||null,last_seen:r}));let i={id:"usb_info_".concat(Date.now()),device_name:e.device_name||"USB-".concat((null===(t=e.iccid)||void 0===t?void 0:t.slice(-4))||(null===(a=e.serial)||void 0===a?void 0:a.slice(-4))||"XXXX"),sim_iccid:e.iccid||null,device_serial:e.serial||null,firmware_version:e.firmware_version||null,status:"usb_connected",last_seen:r,isVirtual:!0,fromUsbInfo:!0};if(w||p?w?_(e=>({...e,...i,firmware_version:i.firmware_version||e.firmware_version,last_seen:r})):p&&S(e=>({...e,...i,firmware_version:i.firmware_version||e.firmware_version,last_seen:r})):S(i),F.current){let t=e.iccid||e.serial||e.device_name;if(t){let a=e.firmware_version||"";F.current(t,a,{last_seen:r,status:"usb_connected"}),l.Z.debug("\uD83D\uDD04 Mise \xe0 jour base de donn\xe9es (device_info):",{identifier:t,firmwareVersion:a||"(non disponible)",last_seen:r})}else l.Z.debug("⚠️ Aucun identifiant disponible dans device_info pour mise \xe0 jour base de donn\xe9es")}else l.Z.debug("⚠️ Callback updateDeviceFirmwareRef non disponible pour device_info");return}if("device_config"===e.type&&!W){let r={sleep_minutes:null!==(n=e.sleep_minutes)&&void 0!==n?n:null,measurement_duration_ms:null!==(i=e.measurement_duration_ms)&&void 0!==i?i:null,calibration_coefficients:e.calibration_coefficients?Array.isArray(e.calibration_coefficients)?e.calibration_coefficients:[e.calibration_coefficients[0]||0,e.calibration_coefficients[1]||1,e.calibration_coefficients[2]||0]:[0,1,0]};E(e=>({...e,config:r})),l.Z.log("✅ Configuration USB stock\xe9e:",{sleep_minutes:r.sleep_minutes,measurement_duration_ms:r.measurement_duration_ms,calibration:r.calibration_coefficients}),window.dispatchEvent(new CustomEvent("usb-device-config-received",{detail:r}));return}if(W){let r=new Date().toISOString();(!e.seq||e.seq<=3)&&l.Z.log("✅ Format unifi\xe9 d\xe9tect\xe9:",{seq:e.seq,mode:e.mode,type:e.type,has_sim_iccid:!!e.sim_iccid,has_device_name:!!e.device_name,has_firmware_version:!!e.firmware_version,has_flow_lpm:null!=e.flow_lpm,has_battery:null!=e.battery_percent});{l.Z.log("\uD83D\uDD0D\uD83D\uDD0D\uD83D\uDD0D [USB] PAYLOAD RE\xc7U:",{type:e.type,mode:e.mode,sim_iccid:e.sim_iccid,device_serial:e.device_serial,device_name:e.device_name,firmware_version:e.firmware_version,allKeys:Object.keys(e)});let t={sim_iccid:e.sim_iccid||null,device_serial:e.device_serial||null,firmware_version:e.firmware_version||null,device_name:e.device_name||null,last_seen:r};E(e=>{let a={...e,sim_iccid:t.sim_iccid||(null==e?void 0:e.sim_iccid)||null,device_serial:t.device_serial||(null==e?void 0:e.device_serial)||null,firmware_version:t.firmware_version||(null==e?void 0:e.firmware_version)||null,device_name:t.device_name||(null==e?void 0:e.device_name)||null,last_seen:r};return l.Z.log("\uD83D\uDCDD [USB] \xc9tat usbDeviceInfo:",{prev_iccid:null==e?void 0:e.sim_iccid,next_iccid:a.sim_iccid,changed:a.sim_iccid!==(null==e?void 0:e.sim_iccid)}),(a.sim_iccid||a.device_serial)&&(a.sim_iccid!==(null==e?void 0:e.sim_iccid)||a.device_serial!==(null==e?void 0:e.device_serial))&&l.Z.log("\uD83D\uDCDD [USB] ✅ Mise \xe0 jour usbDeviceInfo avec NOUVEAUX identifiants:",{sim_iccid:a.sim_iccid,device_serial:a.device_serial,device_name:a.device_name,firmware_version:a.firmware_version}),a});let a={id:"usb_info_".concat(Date.now()),device_name:e.device_name||"USB-".concat((null===(o=e.sim_iccid)||void 0===o?void 0:o.slice(-4))||(null===(s=e.device_serial)||void 0===s?void 0:s.slice(-4))||"XXXX"),sim_iccid:e.sim_iccid||null,device_serial:e.device_serial||null,firmware_version:e.firmware_version||null,status:"usb_connected",last_seen:r,isVirtual:!0,fromUsbInfo:!0};if(w||p?w?_(e=>({...e,...a,firmware_version:a.firmware_version||e.firmware_version,last_seen:r})):p&&S(e=>({...e,...a,firmware_version:a.firmware_version||e.firmware_version,last_seen:r})):S(a),F.current){let t=e.sim_iccid||e.device_serial||e.device_name;if(t){let a=e.firmware_version||"";F.current(t,a,{last_seen:r,status:"usb_connected"})}}}if(null!=e.sleep_minutes||null!=e.measurement_duration_ms||e.calibration_coefficients){let r={sleep_minutes:null!==(u=e.sleep_minutes)&&void 0!==u?u:null,measurement_duration_ms:null!==(c=e.measurement_duration_ms)&&void 0!==c?c:null,calibration_coefficients:e.calibration_coefficients?Array.isArray(e.calibration_coefficients)?e.calibration_coefficients:[e.calibration_coefficients[0]||0,e.calibration_coefficients[1]||1,e.calibration_coefficients[2]||0]:[0,1,0]};l.Z.log("✅ Configuration extraite du format unifi\xe9:",r),E(e=>({...e,config:r})),l.Z.log("\uD83D\uDCE2 \xc9mission \xe9v\xe9nement usb-device-config-received"),window.dispatchEvent(new CustomEvent("usb-device-config-received",{detail:r}))}else l.Z.debug("⚠️ Format unifi\xe9 sans configuration (sleep_minutes, measurement_duration_ms, calibration_coefficients tous null/undefined)");{let t={id:"usb-".concat(null!==(d=e.seq)&&void 0!==d?d:Date.now()),seq:null!==(g=e.seq)&&void 0!==g?g:null,timestamp:Date.now(),flowrate:null!==(f=null!==(b=null!==(m=e.flow_lpm)&&void 0!==m?m:e.flowrate)&&void 0!==b?b:e.flow)&&void 0!==f?f:null,battery:null!==(h=null!==(v=e.battery_percent)&&void 0!==v?v:e.battery)&&void 0!==h?h:null,rssi:null!==(y=e.rssi)&&void 0!==y?y:null,latitude:null!==(Z=e.latitude)&&void 0!==Z?Z:null,longitude:null!==(D=e.longitude)&&void 0!==D?D:null,interval:null!==(P=null!==(M=e.interval_ms)&&void 0!==M?M:e.interval)&&void 0!==P?P:null,raw:{...e,firmware_version:e.firmware_version||null}};(!e.seq||e.seq<=3)&&l.Z.log("\uD83D\uDCCA Mesure USB #"+(e.seq||"?")+":",{flowrate:t.flowrate,battery:t.battery,rssi:t.rssi,gps:t.latitude&&t.longitude?"".concat(t.latitude.toFixed(4),", ").concat(t.longitude.toFixed(4)):"N/A"}),k(e=>[...e,t].slice(-120)),N(t),L(Date.now()),A(null),B("running"),J.current&&J.current.isMaster&&J.current.notifyDataReceived({measurement:t,deviceInfo:I,timestamp:Date.now()}),E(e=>({...e,flowrate:null!==t.flowrate&&void 0!==t.flowrate?t.flowrate:(null==e?void 0:e.flowrate)||null,last_battery:null!==t.battery&&void 0!==t.battery?t.battery:(null==e?void 0:e.last_battery)||null,latitude:null!==t.latitude&&void 0!==t.latitude?t.latitude:(null==e?void 0:e.latitude)||null,longitude:null!==t.longitude&&void 0!==t.longitude?t.longitude:(null==e?void 0:e.longitude)||null,rssi:null!==t.rssi&&void 0!==t.rssi&&-999!==t.rssi?t.rssi:(null==e?void 0:e.rssi)||null,last_seen:r}));let a=w||p;if(a&&(z(t,a),F.current)){let e=a.sim_iccid||a.device_serial||a.device_name;e&&F.current(e,null,{last_seen:r,status:"usb_connected",last_battery:null!==t.battery&&void 0!==t.battery?t.battery:void 0,last_flowrate:null!==t.flowrate&&void 0!==t.flowrate?t.flowrate:void 0,last_rssi:null!==t.rssi&&void 0!==t.rssi&&-999!==t.rssi?t.rssi:void 0})}}return}if("usb_stream"===e.mode||"usb_stream"===e.type||"USB_STREAM"===e.status&&null!=e.flow_lpm||null!=e.flow_lpm&&null!=e.battery_percent&&!e.type){let r={id:"usb-".concat(null!==(U=e.seq)&&void 0!==U?U:Date.now()),seq:null!==(C=e.seq)&&void 0!==C?C:null,timestamp:Date.now(),flowrate:null!==(R=null!==(q=null!==(T=e.flow_lpm)&&void 0!==T?T:e.flowrate)&&void 0!==q?q:e.flow)&&void 0!==R?R:null,battery:null!==(O=null!==(x=e.battery_percent)&&void 0!==x?x:e.battery)&&void 0!==O?O:null,rssi:null!==(j=e.rssi)&&void 0!==j?j:null,latitude:null!==(V=e.latitude)&&void 0!==V?V:null,longitude:null!==(H=e.longitude)&&void 0!==H?H:null,interval:null!==(Y=null!==(X=e.interval_ms)&&void 0!==X?X:e.interval)&&void 0!==Y?Y:null,raw:{...e,firmware_version:e.firmware_version||null}};(!e.seq||e.seq<=3)&&l.Z.log("\uD83D\uDCCA Mesure USB #"+(e.seq||"?")+":",{flowrate:r.flowrate,battery:r.battery,rssi:r.rssi,gps:r.latitude&&r.longitude?"".concat(r.latitude.toFixed(4),", ").concat(r.longitude.toFixed(4)):"N/A"}),k(e=>[...e,r].slice(-120)),N(r),L(Date.now()),A(null),B("running"),J.current&&J.current.isMaster&&J.current.notifyDataReceived({measurement:r,deviceInfo:I,timestamp:Date.now()});let t=new Date().toISOString();E(a=>({...a,sim_iccid:(null==a?void 0:a.sim_iccid)||null,device_serial:(null==a?void 0:a.device_serial)||null,firmware_version:e.firmware_version||(null==a?void 0:a.firmware_version)||null,flowrate:null!==r.flowrate&&void 0!==r.flowrate?r.flowrate:(null==a?void 0:a.flowrate)||null,last_battery:null!==r.battery&&void 0!==r.battery?r.battery:(null==a?void 0:a.last_battery)||null,latitude:null!==r.latitude&&void 0!==r.latitude?r.latitude:(null==a?void 0:a.latitude)||null,longitude:null!==r.longitude&&void 0!==r.longitude?r.longitude:(null==a?void 0:a.longitude)||null,rssi:null!==r.rssi&&void 0!==r.rssi&&-999!==r.rssi?r.rssi:(null==a?void 0:a.rssi)||null,last_seen:t}));let a=w||p;if(a){if(z(r,a),F.current){let n=(null==I?void 0:I.sim_iccid)||(null==I?void 0:I.device_serial)||a.sim_iccid||a.device_serial||a.device_name;if(n){let i=e.firmware_version||(null==I?void 0:I.firmware_version)||a.firmware_version,o={last_seen:t,status:"usb_connected"};null!==r.battery&&void 0!==r.battery&&(o.last_battery=r.battery),null!==r.flowrate&&void 0!==r.flowrate&&(o.last_flowrate=r.flowrate),null!==r.rssi&&void 0!==r.rssi&&-999!==r.rssi&&(o.last_rssi=r.rssi),F.current(n,i||"",o),l.Z.debug("\uD83D\uDD04 Mise \xe0 jour base de donn\xe9es demand\xe9e:",{identifier:n,firmwareVersion:i||"(non disponible)",battery:null!==r.battery&&void 0!==r.battery?r.battery:"(non disponible)",last_seen:t})}else l.Z.debug("⚠️ Aucun identifiant disponible pour mise \xe0 jour base de donn\xe9es")}else l.Z.debug("⚠️ Callback updateDeviceFirmwareRef non disponible")}else l.Z.debug("⚠️ Aucun dispositif USB connect\xe9 pour mise \xe0 jour");return}}catch(e){l.Z.debug("JSON invalide:",r,e);return}},[W,z,w,p,I]),G=(0,n.useCallback)(e=>{var r;if(!e)return;V.current+=e;let t=V.current.split(/\r?\n/);if(V.current=null!==(r=t.pop())&&void 0!==r?r:"",0===t.length&&V.current.length>0){let e=V.current.trim();if(e.startsWith("{")&&e.endsWith("}"))try{JSON.parse(e),Y(e),V.current="";return}catch(e){}}let a=0;t.forEach(e=>{if(e||""===e){let r=e.trim();if(r.startsWith("{")){a++;try{let e=JSON.parse(r);l.Z.log("\uD83D\uDCE5 JSON #".concat(a," - type: ").concat(e.type||e.mode||"unknown",", seq: ").concat(e.seq||"N/A")),(null!=e.sleep_minutes||null!=e.measurement_duration_ms||e.calibration_coefficients)&&l.Z.log("✅ Configuration d\xe9tect\xe9e dans JSON:",{sleep_minutes:e.sleep_minutes,measurement_duration_ms:e.measurement_duration_ms,calibration:e.calibration_coefficients})}catch(e){l.Z.warn("❌ JSON invalide:",e.message,"| Ligne: ".concat(r.substring(0,100)))}}Y(e)}}),t.length>0&&0===a&&l.Z.debug("\uD83D\uDCE5 ".concat(t.length," ligne(s) de log du firmware trait\xe9e(s)")),"waiting"===U&&(l.Z.log("✅ Premier chunk re\xe7u, passage \xe0 running"),B("running"))},[Y,U]),K=(0,n.useCallback)(async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;try{A(null);let r="paused"===U;r?l.Z.log("▶️ [USB] Reprise du streaming USB depuis la pause..."):l.Z.log("\uD83D\uDCE1 [USB] D\xe9marrage du streaming USB..."),B("connecting");let t=e||u,a=t&&t.readable&&t.writable,n=t&&c;if(a||n)l.Z.log("✅ [USB] Port disponible, d\xe9marrage de la lecture"),t&&t!==u&&l.Z.log("\uD83D\uDD04 [USB] Mise \xe0 jour du port dans le contexte...");else if(!t||a||n)throw l.Z.error("❌ [USB] Aucun port USB connect\xe9"),Error("Aucun port USB connect\xe9. Veuillez s\xe9lectionner et connecter un port d'abord.");else{if(l.Z.log("\uD83D\uDD04 [USB] Port existe mais non ouvert, reconnexion..."),!await m(t,115200))throw Error("Impossible de reconnecter au port");l.Z.log("✅ [USB] Port reconnect\xe9")}if(j.current&&!r){l.Z.log("\uD83D\uDED1 [USB] Arr\xeat de l'ancien streaming");try{j.current()}catch(e){l.Z.warn("⚠️ [USB] Erreur lors de l'arr\xeat de l'ancien streaming:",e)}j.current=null,await new Promise(e=>setTimeout(e,300))}r?(V.current="",W("▶️ Reprise du streaming...","dashboard")):(V.current="",k([]),q([]),N(null),L(null)),l.Z.log("\uD83D\uDCD6 [USB] D\xe9marrage de la lecture...");let i=await f(G);if(!i||"function"!=typeof i)throw Error("startReading n'a pas retourn\xe9 de fonction stop valide");j.current=i,B("waiting"),l.Z.log("✅ [USB] Streaming d\xe9marr\xe9, en attente de donn\xe9es...")}catch(r){l.Z.error("❌ [USB] Erreur d\xe9marrage streaming:",r);let e=r.message||"Impossible de d\xe9marrer le streaming USB";A(e),B("idle"),W("❌ Erreur: ".concat(e),"dashboard")}},[X,G,f,W,l.Z,u,c,v,U]),Q=(0,n.useCallback)(function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(j.current){try{e||l.Z.log("⏸️ [USB] Arr\xeat du streaming..."),j.current(),e||l.Z.log("✅ [USB] Fonction stop ex\xe9cut\xe9e")}catch(e){l.Z.warn("⚠️ [USB] Erreur lors de l'arr\xeat du streaming:",e)}j.current=null}else e||l.Z.log("ℹ️ [USB] Aucun streaming actif \xe0 arr\xeater")},[]),$=(0,n.useCallback)(()=>{l.Z.log("⏸️ [USB] Pause du streaming demand\xe9e"),Q(!0),B("paused"),A(null),W("⏸️ Streaming en pause - Les logs sont conserv\xe9s","dashboard"),l.Z.log("✅ [USB] Streaming en pause, port toujours connect\xe9")},[Q,W]),ee=(0,n.useCallback)(()=>{l.Z.log("\uD83D\uDED1 [USB] Arr\xeat complet du streaming demand\xe9"),Q(!0),V.current="",k([]),q([]),N(null),L(null),B("idle"),l.Z.log("✅ [USB] Streaming compl\xe8tement arr\xeat\xe9, \xe9tat r\xe9initialis\xe9")},[Q]),er=(0,n.useCallback)(async function(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0],arguments.length>1&&arguments[1],arguments.length>2&&arguments[2],arguments.length>3&&arguments[3],arguments.length>4&&arguments[4],!d)return l.Z.warn("Web Serial API non support\xe9"),null;P(!0);try{return null}catch(e){return l.Z.error("Erreur d\xe9tection USB:",e),null}finally{P(!1)}},[d]);(0,n.useEffect)(()=>{if(!d){D(!1);return}if(c&&u)return;let e=!0,r=!1,t=async()=>{if(!r&&(!c||!u)){r=!0;try{let t=await navigator.serial.getPorts();if(0===t.length){r=!1;return}for(let a of t)if(u!==a||!c){if(a.readable&&a.writable){if(a.writable.locked||a.readable.locked){l.Z.debug("\uD83D\uDD0C [USB] Port d\xe9j\xe0 ouvert et verrouill\xe9 par un autre onglet, \xe9coute des donn\xe9es partag\xe9es..."),r=!1;return}l.Z.log("\uD83D\uDD0C [USB] Port d\xe9j\xe0 ouvert d\xe9tect\xe9, connexion automatique...");try{if(await m(a,115200)&&e){l.Z.log("✅ [USB] Connexion automatique r\xe9ussie"),W("✅ Connexion automatique au dispositif USB \xe9tablie","dashboard"),setTimeout(async()=>{if(e&&!j.current)try{l.Z.log("\uD83D\uDCE1 [USB] D\xe9marrage automatique du streaming..."),await K(a)}catch(e){l.Z.warn("⚠️ [USB] Erreur d\xe9marrage streaming automatique:",e)}},500),r=!1;return}}catch(e){l.Z.debug("⚠️ [USB] Erreur connexion port d\xe9j\xe0 ouvert:",e.message);continue}}else{l.Z.log("\uD83D\uDD0C [USB] Tentative de connexion automatique au port...");try{if(await m(a,115200)&&e){l.Z.log("✅ [USB] Connexion automatique r\xe9ussie"),W("✅ Connexion automatique au dispositif USB \xe9tablie","dashboard"),setTimeout(async()=>{if(e&&!j.current)try{l.Z.log("\uD83D\uDCE1 [USB] D\xe9marrage automatique du streaming..."),await K(a)}catch(e){l.Z.warn("⚠️ [USB] Erreur d\xe9marrage streaming automatique:",e)}},500),r=!1;return}}catch(e){l.Z.debug("⚠️ [USB] Erreur connexion port:",e.message);continue}}}r=!1}catch(e){l.Z.debug("⚠️ [USB] Erreur d\xe9tection/connexion automatique:",e.message),r=!1}}};t();let a=setInterval(()=>{e&&!c&&t()},3e3);return()=>{e=!1,clearInterval(a)}},[d,c,u,m,K,W]),(0,n.useEffect)(()=>()=>{ee()},[ee]);let et=(0,n.useCallback)(e=>{H.current=e},[]),ea=(0,n.useCallback)(e=>{F.current=e},[]);return(0,a.jsx)(s.Provider,{value:{usbConnectedDevice:w,setUsbConnectedDevice:_,usbVirtualDevice:p,setUsbVirtualDevice:S,usbDeviceInfo:I,usbPortInfo:h,setUsbPortInfo:y,autoDetecting:Z,setAutoDetecting:D,checkingUSB:M,setCheckingUSB:P,isConnected:c,isSupported:d,port:u,usbStreamStatus:U,usbStreamMeasurements:C,usbStreamLogs:T,usbStreamError:R,usbStreamLastMeasurement:x,usbStreamLastUpdate:O,startUsbStreaming:K,pauseUsbStreaming:$,stopUsbStreaming:ee,detectUSBDevice:er,ensurePortReady:X,requestPort:g,connect:m,disconnect:b,startReading:f,write:v,appendUsbStreamLog:W,setSendMeasurementCallback:et,setUpdateDeviceFirmwareCallback:ea},children:r})}function c(){let e=(0,n.useContext)(s);if(!e)throw Error("useUsb must be used within UsbProvider");return e}},542:function(e,r,t){t.d(r,{DE:function(){return l},Yu:function(){return i}});let a=[{usbVendorId:6790,usbProductId:21972,manufacturer:"QinHeng/CH340",label:"OTT Module (CH340 USB-S\xe9rie)"}],n=e=>null==e?"????":e.toString(16).padStart(4,"0");function i(){return a.map(e=>({usbVendorId:e.usbVendorId,usbProductId:e.usbProductId}))}function l(e){if(!e)return null;let r=a.find(r=>r.usbVendorId===e.usbVendorId&&(!r.usbProductId||r.usbProductId===e.usbProductId));return r?r.label:e.usbVendorId||e.usbProductId?"USB ".concat(n(e.usbVendorId),":").concat(n(e.usbProductId)):null}},9629:function(e,r,t){t.d(r,{T:function(){return o}});let a=null;try{a=t(8828).Z||t(8828).k}catch(e){a={debug:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.debug(...r)},warn:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.warn(...r)},error:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.error(...r)},log:function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];return console.log(...r)}}}let n="ott-usb-port-state";class i{generateTabId(){return"tab-".concat(Date.now(),"-").concat(Math.random().toString(36).substr(2,9))}startHeartbeat(){this.heartbeatInterval=setInterval(()=>{if(this.isMaster)this.broadcast({type:"heartbeat",tabId:this.tabId,timestamp:Date.now()}),this.updateStorage({masterTabId:this.tabId,lastHeartbeat:Date.now()});else{let e=this.getStorageState();e&&e.masterTabId&&Date.now()-(e.lastHeartbeat||0)>5e3&&(void 0!==a&&a.debug&&a.debug("[USB Sharing] Master timeout, becoming master"),this.becomeMaster())}},2e3)}stopHeartbeat(){this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null)}checkState(){let e=this.getStorageState();e&&e.masterTabId&&Date.now()-(e.lastHeartbeat||0)<5e3?(this.masterTabId=e.masterTabId,this.isMaster=!1,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:this.masterTabId})):this.becomeMaster()}becomeMaster(){this.isMaster=!0,this.masterTabId=this.tabId,this.updateStorage({masterTabId:this.tabId,lastHeartbeat:Date.now()}),this.broadcast({type:"master-announcement",tabId:this.tabId,timestamp:Date.now()}),this.notifyListeners("state-changed",{isMaster:!0,masterTabId:this.tabId}),void 0!==a&&a.debug&&a.debug("[USB Sharing] Became master tab")}requestMaster(){return this.broadcast({type:"request-master",tabId:this.tabId,timestamp:Date.now()}),new Promise(e=>{setTimeout(()=>{let r=this.getStorageState();r&&r.masterTabId===this.tabId?e(!0):e(!1)},500)})}broadcast(e){this.channel&&this.channel.postMessage({...e,tabId:this.tabId})}handleMessage(e){let{type:r,tabId:t,data:a}=e.data;if(t!==this.tabId)switch(r){case"heartbeat":this.isMaster&&t!==this.tabId?t<this.tabId&&(this.isMaster=!1,this.masterTabId=t,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:t})):this.isMaster||(this.masterTabId=t,this.lastHeartbeat=Date.now());break;case"master-announcement":case"master-response":this.isMaster||(this.masterTabId=t,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:t}));break;case"request-master":this.isMaster&&this.broadcast({type:"master-response",tabId:this.tabId,timestamp:Date.now()});break;case"port-opened":this.notifyListeners("port-opened",a);break;case"port-closed":this.notifyListeners("port-closed",a);break;case"data-received":this.notifyListeners("data-received",a)}}handleStorageChange(e){try{let r=JSON.parse(e||"{}");r.masterTabId&&r.masterTabId!==this.tabId&&(this.masterTabId=r.masterTabId,this.isMaster&&(this.isMaster=!1,this.notifyListeners("state-changed",{isMaster:!1,masterTabId:r.masterTabId})))}catch(e){void 0!==a&&a.warn&&a.warn("[USB Sharing] Error parsing storage change:",e)}}getStorageState(){try{let e=localStorage.getItem(n);return e?JSON.parse(e):null}catch(e){return null}}updateStorage(e){try{localStorage.setItem(n,JSON.stringify({...e,timestamp:Date.now()}))}catch(e){void 0!==a&&a.warn&&a.warn("[USB Sharing] Error updating storage:",e)}}on(e,r){return this.listeners.has(e)||this.listeners.set(e,[]),this.listeners.get(e).push(r),()=>{let t=this.listeners.get(e);if(t){let e=t.indexOf(r);e>-1&&t.splice(e,1)}}}notifyListeners(e,r){let t=this.listeners.get(e);t&&t.forEach(e=>{try{e(r)}catch(e){void 0!==a&&a.error&&a.error("[USB Sharing] Error in listener:",e)}})}notifyPortOpened(e){this.isMaster&&this.broadcast({type:"port-opened",data:e})}notifyPortClosed(){this.isMaster&&this.broadcast({type:"port-closed",data:{tabId:this.tabId}})}notifyDataReceived(e){this.isMaster&&this.broadcast({type:"data-received",data:e})}cleanup(){this.stopHeartbeat(),this.isMaster&&(localStorage.removeItem(n),this.broadcast({type:"master-closed",tabId:this.tabId})),this.channel&&this.channel.close()}constructor(){this.channel="undefined"!=typeof BroadcastChannel?new BroadcastChannel("ott-usb-port-sharing"):null,this.tabId=this.generateTabId(),this.isMaster=!1,this.masterTabId=null,this.heartbeatInterval=null,this.listeners=new Map,this.lastHeartbeat=Date.now(),this.channel&&(this.channel.onmessage=e=>this.handleMessage(e)),window.addEventListener("storage",e=>{e.key===n&&this.handleStorageChange(e.newValue)}),this.startHeartbeat(),this.checkState()}}let l=null;function o(){return l||(l=new i,window.addEventListener("beforeunload",()=>{l.cleanup()})),l}}}]);