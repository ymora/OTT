(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9531],{5252:function(t){t.exports=function(t){return atob(t)}},8139:function(t,e,i){"use strict";i.d(e,{pq:function(){return y}});class s extends Error{}var r=i(3425);class a{constructor(t,e=!1,i=!0){this.device=t,this.tracing=e,this.slipReaderEnabled=!1,this.baudrate=0,this.traceLog="",this.lastTraceTime=Date.now(),this.buffer=new Uint8Array(0),this.SLIP_END=192,this.SLIP_ESC=219,this.SLIP_ESC_END=220,this.SLIP_ESC_ESC=221,this._DTR_state=!1,this.slipReaderEnabled=i}getInfo(){let t=this.device.getInfo();return t.usbVendorId&&t.usbProductId?`WebSerial VendorID 0x${t.usbVendorId.toString(16)} ProductID 0x${t.usbProductId.toString(16)}`:""}getPid(){return this.device.getInfo().usbProductId}trace(t){let e=Date.now()-this.lastTraceTime,i=`TRACE ${e.toFixed(3)}`,s=`${i} ${t}`;console.log(s),this.traceLog+=s+"\n"}async returnTrace(){try{await navigator.clipboard.writeText(this.traceLog),console.log("Text copied to clipboard!")}catch(t){console.error("Failed to copy text:",t)}}hexify(t){return Array.from(t).map(t=>t.toString(16).padStart(2,"0")).join("").padEnd(16," ")}hexConvert(t,e=!0){if(!e||!(t.length>16))return this.hexify(t);{let e="",i=t;for(;i.length>0;){let t=i.slice(0,16),s=String.fromCharCode(...t).split("").map(t=>" "===t||t>=" "&&t<="~"&&"  "!==t?t:".").join("");i=i.slice(16),e+=`
    ${this.hexify(t.slice(0,8))} ${this.hexify(t.slice(8))} | ${s}`}return e}}slipWriter(t){let e=[];e.push(192);for(let i=0;i<t.length;i++)219===t[i]?e.push(219,221):192===t[i]?e.push(219,220):e.push(t[i]);return e.push(192),new Uint8Array(e)}async write(t){let e=this.slipWriter(t);if(this.device.writable){let t=this.device.writable.getWriter();this.tracing&&(console.log("Write bytes"),this.trace(`Write ${e.length} bytes: ${this.hexConvert(e)}`)),await t.write(e),t.releaseLock()}}appendArray(t,e){let i=new Uint8Array(t.length+e.length);return i.set(t),i.set(e,t.length),i}async *readLoop(t){if(this.reader)try{for(;;){let e=new Promise((e,i)=>setTimeout(()=>i(Error("Read timeout exceeded")),t)),i=await Promise.race([this.reader.read(),e]);if(null===i)break;let{value:s,done:r}=i;if(r||!s)break;yield s}}catch(t){console.error("Error reading from serial port:",t)}finally{this.buffer=new Uint8Array(0)}}async newRead(t,e){if(this.buffer.length>=t){let e=this.buffer.slice(0,t);return this.buffer=this.buffer.slice(t),e}for(;this.buffer.length<t;){let t=this.readLoop(e),{value:i,done:s}=await t.next();if(s||!i)break;this.buffer=this.appendArray(this.buffer,i)}let i=this.buffer.slice(0,t);return this.buffer=this.buffer.slice(t),i}async flushInput(){var t;this.reader&&!await this.reader.closed&&(await this.reader.cancel(),this.reader.releaseLock(),this.reader=null===(t=this.device.readable)||void 0===t?void 0:t.getReader())}async flushOutput(){var t,e;this.buffer=new Uint8Array(0),await (null===(t=this.device.writable)||void 0===t?void 0:t.getWriter().close()),null===(e=this.device.writable)||void 0===e||e.getWriter().releaseLock()}inWaiting(){return this.buffer.length}detectPanicHandler(t){let e=new TextDecoder("utf-8").decode(t),i=e.match(/G?uru Meditation Error: (?:Core \d panic'ed \(([a-zA-Z ]*)\))?/)||e.match(/F?atal exception \(\d+\): (?:([a-zA-Z ]*)?.*epc)?/);if(i){let t=i[1]||i[2];throw Error(`Guru Meditation Error detected${t?` (${t})`:""}`)}}async *read(t){var e;this.reader||(this.reader=null===(e=this.device.readable)||void 0===e?void 0:e.getReader());let i=null,s=!1,r=!1;for(;;){let e=this.inWaiting(),a=await this.newRead(e>0?e:1,t);if(!a||0===a.length){let t=null===i?r?"Serial data stream stopped: Possible serial noise or corruption.":"No serial data received.":"Packet content transfer stopped";throw this.trace(t),Error(t)}this.trace(`Read ${a.length} bytes: ${this.hexConvert(a)}`);let n=0;for(;n<a.length;){let e=a[n++];if(null===i){if(e===this.SLIP_END)i=new Uint8Array(0);else{this.trace(`Read invalid data: ${this.hexConvert(a)}`);let i=await this.newRead(this.inWaiting(),t);throw this.trace(`Remaining data in serial buffer: ${this.hexConvert(i)}`),this.detectPanicHandler(new Uint8Array([...a,...i||[]])),Error(`Invalid head of packet (0x${e.toString(16)}): Possible serial noise or corruption.`)}}else if(s){if(s=!1,e===this.SLIP_ESC_END)i=this.appendArray(i,new Uint8Array([this.SLIP_END]));else if(e===this.SLIP_ESC_ESC)i=this.appendArray(i,new Uint8Array([this.SLIP_ESC]));else{this.trace(`Read invalid data: ${this.hexConvert(a)}`);let i=await this.newRead(this.inWaiting(),t);throw this.trace(`Remaining data in serial buffer: ${this.hexConvert(i)}`),this.detectPanicHandler(new Uint8Array([...a,...i||[]])),Error(`Invalid SLIP escape (0xdb, 0x${e.toString(16)})`)}}else e===this.SLIP_ESC?s=!0:e===this.SLIP_END?(this.trace(`Received full packet: ${this.hexConvert(i)}`),this.buffer=this.appendArray(this.buffer,a.slice(n)),yield i,i=null,r=!0):i=this.appendArray(i,new Uint8Array([e]))}}}async *rawRead(){if(this.reader)try{for(;;){let{value:t,done:e}=await this.reader.read();if(e||!t)break;this.tracing&&(console.log("Raw Read bytes"),this.trace(`Read ${t.length} bytes: ${this.hexConvert(t)}`)),yield t}}catch(t){console.error("Error reading from serial port:",t)}finally{this.buffer=new Uint8Array(0)}}async setRTS(t){await this.device.setSignals({requestToSend:t}),await this.setDTR(this._DTR_state)}async setDTR(t){this._DTR_state=t,await this.device.setSignals({dataTerminalReady:t})}async connect(t=115200,e={}){var i;await this.device.open({baudRate:t,dataBits:null==e?void 0:e.dataBits,stopBits:null==e?void 0:e.stopBits,bufferSize:null==e?void 0:e.bufferSize,parity:null==e?void 0:e.parity,flowControl:null==e?void 0:e.flowControl}),this.baudrate=t,this.reader=null===(i=this.device.readable)||void 0===i?void 0:i.getReader()}async sleep(t){return new Promise(e=>setTimeout(e,t))}async waitForUnlock(t){for(;this.device.readable&&this.device.readable.locked||this.device.writable&&this.device.writable.locked;)await this.sleep(t)}async disconnect(){var t,e;(null===(t=this.device.readable)||void 0===t?void 0:t.locked)&&await (null===(e=this.reader)||void 0===e?void 0:e.cancel()),await this.waitForUnlock(400),await this.device.close(),this.reader=void 0}}function n(t){return new Promise(e=>setTimeout(e,t))}class h{constructor(t,e){this.resetDelay=e,this.transport=t}async reset(){await this.transport.setDTR(!1),await this.transport.setRTS(!0),await n(100),await this.transport.setDTR(!0),await this.transport.setRTS(!1),await n(this.resetDelay),await this.transport.setDTR(!1)}}class o{constructor(t){this.transport=t}async reset(){await this.transport.setRTS(!1),await this.transport.setDTR(!1),await n(100),await this.transport.setDTR(!0),await this.transport.setRTS(!1),await n(100),await this.transport.setRTS(!0),await this.transport.setDTR(!1),await this.transport.setRTS(!0),await n(100),await this.transport.setRTS(!1),await this.transport.setDTR(!1)}}class l{constructor(t,e=!1){this.transport=t,this.usingUsbOtg=e,this.transport=t}async reset(){this.usingUsbOtg?(await n(200),await this.transport.setRTS(!1),await n(200)):(await n(100),await this.transport.setRTS(!1))}}class c{constructor(t,e){this.transport=t,this.sequenceString=e,this.transport=t}async reset(){let t={D:async t=>await this.transport.setDTR(t),R:async t=>await this.transport.setRTS(t),W:async t=>await n(t)};try{if(!function(t){let e=["D","R","W"];for(let i of t.split("|")){let t=i[0],s=i.slice(1);if(!e.includes(t))return!1;if("D"===t||"R"===t){if("0"!==s&&"1"!==s)return!1}else if("W"===t){let t=parseInt(s);if(isNaN(t)||t<=0)return!1}}return!0}(this.sequenceString))return;for(let e of this.sequenceString.split("|")){let i=e[0],s=e.slice(1);"W"===i?await t.W(Number(s)):("D"===i||"R"===i)&&await t[i]("1"===s)}}catch(t){throw Error("Invalid custom reset sequence")}}}var d=i(5252),u=i.n(d);async function _(t){let e;switch(t){case"ESP32":e=await i.e(1421).then(i.t.bind(i,1421,19));break;case"ESP32-C2":e=await i.e(4592).then(i.t.bind(i,3732,19));break;case"ESP32-C3":e=await i.e(4961).then(i.t.bind(i,4961,19));break;case"ESP32-C5":e=await i.e(6396).then(i.t.bind(i,6396,19));break;case"ESP32-C6":e=await i.e(8224).then(i.t.bind(i,8224,19));break;case"ESP32-C61":e=await i.e(9481).then(i.t.bind(i,9481,19));break;case"ESP32-H2":e=await i.e(3811).then(i.t.bind(i,3811,19));break;case"ESP32-P4":e=await i.e(3802).then(i.t.bind(i,3802,19));break;case"ESP32-S2":e=await i.e(9788).then(i.t.bind(i,9788,19));break;case"ESP32-S3":e=await i.e(9887).then(i.t.bind(i,9887,19));break;case"ESP8266":e=await i.e(5963).then(i.t.bind(i,5963,19))}if(e)return{bss_start:e.bss_start,data:e.data,data_start:e.data_start,entry:e.entry,text:e.text,text_start:e.text_start,decodedData:f(e.data),decodedText:f(e.text)}}function f(t){return new Uint8Array(u()(t).split("").map(function(t){return t.charCodeAt(0)}))}async function p(t){switch(t){case 15736195:{let{ESP32ROM:t}=await i.e(8146).then(i.bind(i,8146));return new t}case 203546735:case 1867591791:case 2084675695:{let{ESP32C2ROM:t}=await i.e(1783).then(i.bind(i,3668));return new t}case 1763790959:case 456216687:case 1216438383:case 1130455151:{let{ESP32C3ROM:t}=await i.e(7456).then(i.bind(i,7456));return new t}case 752910447:{let{ESP32C6ROM:t}=await i.e(3771).then(i.bind(i,3771));return new t}case 606167151:case 871374959:case 1333878895:{let{ESP32C61ROM:t}=await i.e(466).then(i.bind(i,466));return new t}case 285294703:case 1675706479:case 1607549039:{let{ESP32C5ROM:t}=await i.e(8958).then(i.bind(i,8958));return new t}case 3619110528:case 2548236392:{let{ESP32H2ROM:t}=await i.e(1231).then(i.bind(i,1231));return new t}case 9:{let{ESP32S3ROM:t}=await i.e(5326).then(i.bind(i,5326));return new t}case 1990:{let{ESP32S2ROM:t}=await i.e(5642).then(i.bind(i,5642));return new t}case 4293968129:{let{ESP8266ROM:t}=await i.e(1502).then(i.bind(i,1502));return new t}case 0:case 182303440:case 117676761:{let{ESP32P4ROM:t}=await i.e(2467).then(i.bind(i,2467));return new t}default:return null}}class y{constructor(t){var e,i,s,r,n,d,u,_;this.ESP_RAM_BLOCK=6144,this.ESP_FLASH_BEGIN=2,this.ESP_FLASH_DATA=3,this.ESP_FLASH_END=4,this.ESP_MEM_BEGIN=5,this.ESP_MEM_END=6,this.ESP_MEM_DATA=7,this.ESP_WRITE_REG=9,this.ESP_READ_REG=10,this.ESP_SPI_ATTACH=13,this.ESP_CHANGE_BAUDRATE=15,this.ESP_FLASH_DEFL_BEGIN=16,this.ESP_FLASH_DEFL_DATA=17,this.ESP_FLASH_DEFL_END=18,this.ESP_SPI_FLASH_MD5=19,this.ESP_ERASE_FLASH=208,this.ESP_ERASE_REGION=209,this.ESP_READ_FLASH=210,this.ESP_RUN_USER_CODE=211,this.ESP_IMAGE_MAGIC=233,this.ESP_CHECKSUM_MAGIC=239,this.ROM_INVALID_RECV_MSG=5,this.DEFAULT_TIMEOUT=3e3,this.ERASE_REGION_TIMEOUT_PER_MB=3e4,this.ERASE_WRITE_TIMEOUT_PER_MB=4e4,this.MD5_TIMEOUT_PER_MB=8e3,this.CHIP_ERASE_TIMEOUT=12e4,this.FLASH_READ_TIMEOUT=1e5,this.MAX_TIMEOUT=2*this.CHIP_ERASE_TIMEOUT,this.CHIP_DETECT_MAGIC_REG_ADDR=1073745920,this.DETECTED_FLASH_SIZES={18:"256KB",19:"512KB",20:"1MB",21:"2MB",22:"4MB",23:"8MB",24:"16MB"},this.DETECTED_FLASH_SIZES_NUM={18:256,19:512,20:1024,21:2048,22:4096,23:8192,24:16384},this.USB_JTAG_SERIAL_PID=4097,this.romBaudrate=115200,this.debugLogging=!1,this.syncStubDetected=!1,this.flashSizeBytes=function(t){let e=-1;return -1!==t.indexOf("KB")?e=1024*parseInt(t.slice(0,t.indexOf("KB"))):-1!==t.indexOf("MB")&&(e=1048576*parseInt(t.slice(0,t.indexOf("MB")))),e},this.IS_STUB=!1,this.FLASH_WRITE_SIZE=16384,this.transport=t.transport,this.baudrate=t.baudrate,this.resetConstructors={classicReset:(t,e)=>new h(t,e),customReset:(t,e)=>new c(t,e),hardReset:(t,e)=>new l(t,e),usbJTAGSerialReset:t=>new o(t)},t.serialOptions&&(this.serialOptions=t.serialOptions),t.romBaudrate&&(this.romBaudrate=t.romBaudrate),t.terminal&&(this.terminal=t.terminal,this.terminal.clean()),void 0!==t.debugLogging&&(this.debugLogging=t.debugLogging),t.port&&(this.transport=new a(t.port)),void 0!==t.enableTracing&&(this.transport.tracing=t.enableTracing),(null===(e=t.resetConstructors)||void 0===e?void 0:e.classicReset)&&(this.resetConstructors.classicReset=null===(i=t.resetConstructors)||void 0===i?void 0:i.classicReset),(null===(s=t.resetConstructors)||void 0===s?void 0:s.customReset)&&(this.resetConstructors.customReset=null===(r=t.resetConstructors)||void 0===r?void 0:r.customReset),(null===(n=t.resetConstructors)||void 0===n?void 0:n.hardReset)&&(this.resetConstructors.hardReset=null===(d=t.resetConstructors)||void 0===d?void 0:d.hardReset),(null===(u=t.resetConstructors)||void 0===u?void 0:u.usbJTAGSerialReset)&&(this.resetConstructors.usbJTAGSerialReset=null===(_=t.resetConstructors)||void 0===_?void 0:_.usbJTAGSerialReset),this.info("esptool.js"),this.info("Serial port "+this.transport.getInfo())}_sleep(t){return new Promise(e=>setTimeout(e,t))}write(t,e=!0){this.terminal?e?this.terminal.writeLine(t):this.terminal.write(t):console.log(t)}error(t,e=!0){this.write(`Error: ${t}`,e)}info(t,e=!0){this.write(t,e)}debug(t,e=!0){this.debugLogging&&this.write(`Debug: ${t}`,e)}_shortToBytearray(t){return new Uint8Array([255&t,t>>8&255])}_intToByteArray(t){return new Uint8Array([255&t,t>>8&255,t>>16&255,t>>24&255])}_byteArrayToShort(t,e){return t|e>>8}_byteArrayToInt(t,e,i,s){return t|e<<8|i<<16|s<<24}_appendBuffer(t,e){let i=new Uint8Array(t.byteLength+e.byteLength);return i.set(new Uint8Array(t),0),i.set(new Uint8Array(e),t.byteLength),i.buffer}_appendArray(t,e){let i=new Uint8Array(t.length+e.length);return i.set(t,0),i.set(e,t.length),i}ui8ToBstr(t){let e="";for(let i=0;i<t.length;i++)e+=String.fromCharCode(t[i]);return e}bstrToUi8(t){let e=new Uint8Array(t.length);for(let i=0;i<t.length;i++)e[i]=t.charCodeAt(i);return e}async flushInput(){try{await this.transport.flushInput()}catch(t){this.error(t.message)}}async readPacket(t=null,e=this.DEFAULT_TIMEOUT){for(let i=0;i<100;i++){let{value:i}=await this.transport.read(e).next();if(!i||i.length<8)continue;let r=i[0];if(1!==r)continue;let a=i[1],n=this._byteArrayToInt(i[4],i[5],i[6],i[7]),h=i.slice(8);if(1==r){if(null==t||a==t)return[n,h];if(0!=h[0]&&h[1]==this.ROM_INVALID_RECV_MSG)throw await this.flushInput(),new s("unsupported command error")}}throw new s("invalid response")}async command(t=null,e=new Uint8Array(0),i=0,s=!0,r=this.DEFAULT_TIMEOUT){if(null!=t){let a;this.transport.tracing&&this.transport.trace(`command op:0x${t.toString(16).padStart(2,"0")} data len=${e.length} wait_response=${s?1:0} timeout=${(r/1e3).toFixed(3)} data=${this.transport.hexConvert(e)}`);let n=new Uint8Array(8+e.length);for(a=0,n[0]=0,n[1]=t,n[2]=this._shortToBytearray(e.length)[0],n[3]=this._shortToBytearray(e.length)[1],n[4]=this._intToByteArray(i)[0],n[5]=this._intToByteArray(i)[1],n[6]=this._intToByteArray(i)[2],n[7]=this._intToByteArray(i)[3];a<e.length;a++)n[8+a]=e[a];await this.transport.write(n)}return s?this.readPacket(t,r):[0,new Uint8Array(0)]}async readReg(t,e=this.DEFAULT_TIMEOUT){let i=this._intToByteArray(t);return(await this.command(this.ESP_READ_REG,i,void 0,void 0,e))[0]}async writeReg(t,e,i=4294967295,s=0,r=0){let a=this._appendArray(this._intToByteArray(t),this._intToByteArray(e));a=this._appendArray(a,this._intToByteArray(i)),a=this._appendArray(a,this._intToByteArray(s)),r>0&&(a=this._appendArray(a,this._intToByteArray(this.chip.UART_DATE_REG_ADDR)),a=this._appendArray(a,this._intToByteArray(0)),a=this._appendArray(a,this._intToByteArray(0)),a=this._appendArray(a,this._intToByteArray(r))),await this.checkCommand("write target memory",this.ESP_WRITE_REG,a)}async sync(){let t;this.debug("Sync");let e=new Uint8Array(36);for(t=0,e[0]=7,e[1]=7,e[2]=18,e[3]=32;t<32;t++)e[4+t]=85;try{let t=await this.command(8,e,void 0,void 0,100);this.syncStubDetected=0===t[0];for(let e=0;e<7;e++)t=await this.command(),this.syncStubDetected=this.syncStubDetected&&0===t[0];return t}catch(t){throw this.debug("Sync err "+t),t}}async _connectAttempt(t="default_reset",e){this.debug("_connect_attempt "+t),e&&await e.reset();let i=this.transport.inWaiting(),s=Array.from(await this.transport.newRead(i>0?i:1,this.DEFAULT_TIMEOUT),t=>String.fromCharCode(t)).join("").match(/boot:(0x[0-9a-fA-F]+)(.*waiting for download)?/),r=!1,a="",n=!1;s&&(r=!0,a=s[1],n=!!s[2]);let h="";for(let t=0;t<5;t++)try{this.debug(`Sync connect attempt ${t}`);let e=await this.sync();return this.debug(e[0].toString()),"success"}catch(t){this.debug(`Error at sync ${t}`),h=t instanceof Error?t.message:"string"==typeof t?t:JSON.stringify(t)}return r&&(h=`Wrong boot mode detected (${a}).
        This chip needs to be in download mode.`,n&&(h=`Download mode successfully detected, but getting no sync reply:
           The serial TX path seems to be down.`)),h}constructResetSequence(t){if("no_reset"!==t){if("usb_reset"===t||this.transport.getPid()===this.USB_JTAG_SERIAL_PID){if(this.resetConstructors.usbJTAGSerialReset)return this.debug("using USB JTAG Serial Reset"),[this.resetConstructors.usbJTAGSerialReset(this.transport)]}else if(this.resetConstructors.classicReset)return this.debug("using Classic Serial Reset"),[this.resetConstructors.classicReset(this.transport,50),this.resetConstructors.classicReset(this.transport,550)]}return[]}async connect(t="default_reset",e=7,i=!0){let r;this.info("Connecting...",!1),await this.transport.connect(this.romBaudrate,this.serialOptions);let a=this.constructResetSequence(t);for(let i=0;i<e;i++){let e=a.length>0?a[i%a.length]:null;if("success"===(r=await this._connectAttempt(t,e)))break}if("success"!==r)throw new s("Failed to connect with the device");if(this.debug("Connect attempt successful."),this.info("\n\r",!1),i){let t=await this.readReg(this.CHIP_DETECT_MAGIC_REG_ADDR)>>>0;this.debug("Chip Magic "+t.toString(16));let e=await p(t);if(null===this.chip)throw new s(`Unexpected CHIP magic value ${t}. Failed to autodetect chip type.`);this.chip=e}}async detectChip(t="default_reset"){await this.connect(t),this.info("Detecting chip type... ",!1),null!=this.chip?this.info(this.chip.CHIP_NAME):this.info("unknown!")}async checkCommand(t="",e=null,i=new Uint8Array(0),s=0,r=this.DEFAULT_TIMEOUT){this.debug("check_command "+t);let a=await this.command(e,i,s,void 0,r);return a[1].length>4?a[1]:a[0]}async memBegin(t,e,i,r){if(this.IS_STUB){let e=r+t,i=await _(this.chip.CHIP_NAME);if(i){for(let[t,a]of[[i.bss_start||i.data_start,i.data_start+i.decodedData.length],[i.text_start,i.text_start+i.decodedText.length]])if(r<a&&e>t)throw new s(`Software loader is resident at 0x${t.toString(16).padStart(8,"0")}-0x${a.toString(16).padStart(8,"0")}.
            Can't load binary at overlapping address range 0x${r.toString(16).padStart(8,"0")}-0x${e.toString(16).padStart(8,"0")}.
            Either change binary loading address, or use the no-stub option to disable the software loader.`)}}this.debug("mem_begin "+t+" "+e+" "+i+" "+r.toString(16));let a=this._appendArray(this._intToByteArray(t),this._intToByteArray(e));a=this._appendArray(a,this._intToByteArray(i)),a=this._appendArray(a,this._intToByteArray(r)),await this.checkCommand("enter RAM download mode",this.ESP_MEM_BEGIN,a)}checksum(t,e=this.ESP_CHECKSUM_MAGIC){for(let i=0;i<t.length;i++)e^=t[i];return e}async memBlock(t,e){let i=this._appendArray(this._intToByteArray(t.length),this._intToByteArray(e));i=this._appendArray(i,this._intToByteArray(0)),i=this._appendArray(i,this._intToByteArray(0)),i=this._appendArray(i,t);let s=this.checksum(t);await this.checkCommand("write to target RAM",this.ESP_MEM_DATA,i,s)}async memFinish(t){let e=this._appendArray(this._intToByteArray(0===t?1:0),this._intToByteArray(t));await this.checkCommand("leave RAM download mode",this.ESP_MEM_END,e,void 0,200)}async flashSpiAttach(t){let e=this._intToByteArray(t);await this.checkCommand("configure SPI flash pins",this.ESP_SPI_ATTACH,e)}timeoutPerMb(t,e){let i=e/1e6*t;return i<3e3?3e3:i}async flashBegin(t,e){let i=Math.floor((t+this.FLASH_WRITE_SIZE-1)/this.FLASH_WRITE_SIZE),s=this.chip.getEraseSize(e,t),r=new Date,a=r.getTime(),n=3e3;!1==this.IS_STUB&&(n=this.timeoutPerMb(this.ERASE_REGION_TIMEOUT_PER_MB,t)),this.debug("flash begin "+s+" "+i+" "+this.FLASH_WRITE_SIZE+" "+e+" "+t);let h=this._appendArray(this._intToByteArray(s),this._intToByteArray(i));h=this._appendArray(h,this._intToByteArray(this.FLASH_WRITE_SIZE)),h=this._appendArray(h,this._intToByteArray(e)),!1==this.IS_STUB&&(h=this._appendArray(h,this._intToByteArray(0))),await this.checkCommand("enter Flash download mode",this.ESP_FLASH_BEGIN,h,void 0,n);let o=r.getTime();return 0!=t&&!1==this.IS_STUB&&this.info("Took "+(o-a)/1e3+"."+(o-a)%1e3+"s to erase flash block"),i}async flashDeflBegin(t,e,i){let s,r;let a=Math.floor((e+this.FLASH_WRITE_SIZE-1)/this.FLASH_WRITE_SIZE),n=Math.floor((t+this.FLASH_WRITE_SIZE-1)/this.FLASH_WRITE_SIZE),h=new Date,o=h.getTime();this.IS_STUB?(s=t,r=this.DEFAULT_TIMEOUT):(s=n*this.FLASH_WRITE_SIZE,r=this.timeoutPerMb(this.ERASE_REGION_TIMEOUT_PER_MB,s)),this.info("Compressed "+t+" bytes to "+e+"...");let l=this._appendArray(this._intToByteArray(s),this._intToByteArray(a));l=this._appendArray(l,this._intToByteArray(this.FLASH_WRITE_SIZE)),l=this._appendArray(l,this._intToByteArray(i)),("ESP32-S2"===this.chip.CHIP_NAME||"ESP32-S3"===this.chip.CHIP_NAME||"ESP32-C3"===this.chip.CHIP_NAME||"ESP32-C2"===this.chip.CHIP_NAME)&&!1===this.IS_STUB&&(l=this._appendArray(l,this._intToByteArray(0))),await this.checkCommand("enter compressed flash mode",this.ESP_FLASH_DEFL_BEGIN,l,void 0,r);let c=h.getTime();return 0!=t&&!1===this.IS_STUB&&this.info("Took "+(c-o)/1e3+"."+(c-o)%1e3+"s to erase flash block"),a}async flashBlock(t,e,i){let s=this._appendArray(this._intToByteArray(t.length),this._intToByteArray(e));s=this._appendArray(s,this._intToByteArray(0)),s=this._appendArray(s,this._intToByteArray(0)),s=this._appendArray(s,t);let r=this.checksum(t);await this.checkCommand("write to target Flash after seq "+e,this.ESP_FLASH_DATA,s,r,i)}async flashDeflBlock(t,e,i){let s=this._appendArray(this._intToByteArray(t.length),this._intToByteArray(e));s=this._appendArray(s,this._intToByteArray(0)),s=this._appendArray(s,this._intToByteArray(0)),s=this._appendArray(s,t);let r=this.checksum(t);this.debug("flash_defl_block "+t[0].toString(16)+" "+t[1].toString(16)),await this.checkCommand("write compressed data to flash after seq "+e,this.ESP_FLASH_DEFL_DATA,s,r,i)}async flashFinish(t=!1){let e=this._intToByteArray(t?0:1);await this.checkCommand("leave Flash mode",this.ESP_FLASH_END,e)}async flashDeflFinish(t=!1){let e=this._intToByteArray(t?0:1);await this.checkCommand("leave compressed flash mode",this.ESP_FLASH_DEFL_END,e)}async runSpiflashCommand(t,e,i){let r,a;let n=this.chip.SPI_REG_BASE,h=n+0,o=n+this.chip.SPI_USR_OFFS,l=n+this.chip.SPI_USR1_OFFS,c=n+this.chip.SPI_USR2_OFFS,d=n+this.chip.SPI_W0_OFFS;if(r=null!=this.chip.SPI_MOSI_DLEN_OFFS?async(t,e)=>{let i=n+this.chip.SPI_MOSI_DLEN_OFFS,s=n+this.chip.SPI_MISO_DLEN_OFFS;t>0&&await this.writeReg(i,t-1),e>0&&await this.writeReg(s,e-1)}:async(t,e)=>{await this.writeReg(l,(0===e?0:e-1)<<8|(0===t?0:t-1)<<17)},i>32)throw new s("Reading more than 32 bits back from a SPI flash operation is unsupported");if(e.length>64)throw new s("Writing more than 64 bytes of data with one SPI command is unsupported");let u=8*e.length,_=await this.readReg(o),f=await this.readReg(c),p=-2147483648;i>0&&(p|=268435456),u>0&&(p|=134217728),await r(u,i),await this.writeReg(o,p);let y=1879048192|t;if(await this.writeReg(c,y),0==u)await this.writeReg(d,0);else{if(e.length%4!=0){let t=new Uint8Array(e.length%4);e=this._appendArray(e,t)}let t=d;for(a=0;a<e.length-4;a+=4)y=this._byteArrayToInt(e[a],e[a+1],e[a+2],e[a+3]),await this.writeReg(t,y),t+=4}for(await this.writeReg(h,262144),a=0;a<10&&0!=(y=await this.readReg(h)&262144);a++);if(10===a)throw new s("SPI command did not complete in time");let S=await this.readReg(d);return await this.writeReg(o,_),await this.writeReg(c,f),S}async readFlashId(){let t=new Uint8Array(0);return await this.runSpiflashCommand(159,t,24)}async eraseFlash(){this.info("Erasing flash (this may take a while)...");let t=new Date,e=t.getTime(),i=await this.checkCommand("erase flash",this.ESP_ERASE_FLASH,void 0,void 0,this.CHIP_ERASE_TIMEOUT),s=(t=new Date).getTime();return this.info("Chip erase completed successfully in "+(s-e)/1e3+"s"),i}toHex(t){return Array.prototype.map.call(t,t=>("00"+t.toString(16)).slice(-2)).join("")}async flashMd5sum(t,e){let i=this.timeoutPerMb(this.MD5_TIMEOUT_PER_MB,e),s=this._appendArray(this._intToByteArray(t),this._intToByteArray(e));s=this._appendArray(s,this._intToByteArray(0)),s=this._appendArray(s,this._intToByteArray(0));let r=await this.checkCommand("calculate md5sum",this.ESP_SPI_FLASH_MD5,s,void 0,i);return r instanceof Uint8Array&&r.length>16&&(r=r.slice(0,16)),this.toHex(r)}async readFlash(t,e,i=null){let r=this._appendArray(this._intToByteArray(t),this._intToByteArray(e));r=this._appendArray(r,this._intToByteArray(4096)),r=this._appendArray(r,this._intToByteArray(1024));let a=await this.checkCommand("read flash",this.ESP_READ_FLASH,r);if(0!=a)throw new s("Failed to read memory: "+a);let n=new Uint8Array(0);for(;n.length<e;){let{value:t}=await this.transport.read(this.FLASH_READ_TIMEOUT).next();if(t instanceof Uint8Array)t.length>0&&(n=this._appendArray(n,t),await this.transport.write(this._intToByteArray(n.length)),i&&i(t,n.length,e));else throw new s("Failed to read memory: "+t)}return n}async runStub(){if(this.syncStubDetected)return this.info("Stub is already running. No upload is necessary."),this.chip;this.info("Uploading stub...");let t=await _(this.chip.CHIP_NAME);if(void 0===t)throw this.debug("Error loading Stub json"),Error("Error loading Stub json");let e=[t.decodedText,t.decodedData];for(let i=0;i<e.length;i++)if(e[i]){let s=0===i?t.text_start:t.data_start,r=e[i].length,a=Math.floor((r+this.ESP_RAM_BLOCK-1)/this.ESP_RAM_BLOCK);await this.memBegin(r,a,this.ESP_RAM_BLOCK,s);for(let t=0;t<a;t++){let s=t*this.ESP_RAM_BLOCK,r=s+this.ESP_RAM_BLOCK;await this.memBlock(e[i].slice(s,r),t)}}this.info("Running stub..."),await this.memFinish(t.entry);let{value:i}=await this.transport.read(this.DEFAULT_TIMEOUT).next(),r=String.fromCharCode(...i);if("OHAI"!==r)throw new s(`Failed to start stub. Unexpected response ${r}`);return this.info("Stub running..."),this.IS_STUB=!0,this.chip}async changeBaud(){this.info("Changing baudrate to "+this.baudrate);let t=this.IS_STUB?this.romBaudrate:0,e=this._appendArray(this._intToByteArray(this.baudrate),this._intToByteArray(t));await this.command(this.ESP_CHANGE_BAUDRATE,e),this.info("Changed"),await this.transport.disconnect(),await this._sleep(50),await this.transport.connect(this.baudrate,this.serialOptions)}async main(t="default_reset"){await this.detectChip(t);let e=await this.chip.getChipDescription(this);return this.info("Chip is "+e),this.info("Features: "+await this.chip.getChipFeatures(this)),this.info("Crystal is "+await this.chip.getCrystalFreq(this)+"MHz"),this.info("MAC: "+await this.chip.readMac(this)),await this.chip.readMac(this),void 0!==this.chip.postConnect&&await this.chip.postConnect(this),await this.runStub(),this.romBaudrate!==this.baudrate&&await this.changeBaud(),e}parseFlashSizeArg(t){if(void 0===this.chip.FLASH_SIZES[t])throw new s("Flash size "+t+" is not supported by this chip type. Supported sizes: "+this.chip.FLASH_SIZES);return this.chip.FLASH_SIZES[t]}_updateImageFlashParams(t,e,i,s,r){if(this.debug("_update_image_flash_params "+i+" "+s+" "+r),t.length<8||e!=this.chip.BOOTLOADER_FLASH_OFFSET)return t;if("keep"===i&&"keep"===s&&"keep"===r)return this.info("Not changing the image"),t;let a=parseInt(t[0]),n=parseInt(t[2]),h=parseInt(t[3]);if(a!==this.ESP_IMAGE_MAGIC)return this.info("Warning: Image file at 0x"+e.toString(16)+" doesn't look like an image file, so not changing any flash settings."),t;"keep"!==s&&(n=({qio:0,qout:1,dio:2,dout:3})[s]);let o=15&h;"keep"!==r&&(o=({"40m":0,"26m":1,"20m":2,"80m":15})[r]);let l=240&h;"keep"!==i&&(l=this.parseFlashSizeArg(i));let c=n<<8|o+l;return this.info("Flash params set to "+c.toString(16)),parseInt(t[2])!==n<<8&&(t=t.substring(0,2)+(n<<8).toString()+t.substring(3)),parseInt(t[3])!==o+l&&(t=t.substring(0,3)+(o+l).toString()+t.substring(4)),t}async writeFlash(t){let e,i;if(this.debug("EspLoader program"),"keep"!==t.flashSize){let e=this.flashSizeBytes(t.flashSize);for(let i=0;i<t.fileArray.length;i++)if(t.fileArray[i].data.length+t.fileArray[i].address>e)throw new s(`File ${i+1} doesn't fit in the available flash`)}!0===this.IS_STUB&&!0===t.eraseAll&&await this.eraseFlash();for(let a=0;a<t.fileArray.length;a++){let n;if(this.debug("Data Length "+t.fileArray[a].data.length),e=t.fileArray[a].data,this.debug("Image Length "+e.length),0===e.length){this.debug("Warning: File is empty");continue}e=this.ui8ToBstr(function(t,e,i=255){let s=t.length%4;if(0!==s){let e=new Uint8Array(4-s).fill(i),r=new Uint8Array(t.length+e.length);return r.set(t),r.set(e,t.length),r}return t}(this.bstrToUi8(e),0)),i=t.fileArray[a].address,e=this._updateImageFlashParams(e,i,t.flashSize,t.flashMode,t.flashFreq);let h=null;t.calculateMD5Hash&&(h=t.calculateMD5Hash(e),this.debug("Image MD5 "+h));let o=e.length;if(t.compress){let t=this.bstrToUi8(e);e=this.ui8ToBstr((0,r.Wt)(t,{level:9})),n=await this.flashDeflBegin(o,e.length,i)}else n=await this.flashBegin(o,i);let l=0,c=0,d=e.length;t.reportProgress&&t.reportProgress(a,0,d);let u=new Date,_=u.getTime(),f=5e3,p=new r.T_({chunkSize:1}),y=0;for(p.onData=function(t){y+=t.byteLength};e.length>0;){this.debug("Write loop "+i+" "+l+" "+n),this.info("Writing at 0x"+(i+y).toString(16)+"... ("+Math.floor(100*(l+1)/n)+"%)");let r=this.bstrToUi8(e.slice(0,this.FLASH_WRITE_SIZE));if(t.compress){let t=y;p.push(r,!1);let e=y-t,i=3e3;this.timeoutPerMb(this.ERASE_WRITE_TIMEOUT_PER_MB,e)>3e3&&(i=this.timeoutPerMb(this.ERASE_WRITE_TIMEOUT_PER_MB,e)),!1===this.IS_STUB&&(f=i),await this.flashDeflBlock(r,l,f),this.IS_STUB&&(f=i)}else throw new s("Yet to handle Non Compressed writes");c+=r.length,e=e.slice(this.FLASH_WRITE_SIZE,e.length),l++,t.reportProgress&&t.reportProgress(a,c,d)}this.IS_STUB&&await this.readReg(this.CHIP_DETECT_MAGIC_REG_ADDR,f);let S=(u=new Date).getTime()-_;if(t.compress&&this.info("Wrote "+o+" bytes ("+c+" compressed) at 0x"+i.toString(16)+" in "+S/1e3+" seconds."),h){let t=await this.flashMd5sum(i,o);if(new String(t).valueOf()!=new String(h).valueOf())throw this.info("File  md5: "+h),this.info("Flash md5: "+t),new s("MD5 of file does not match data in flash!");this.info("Hash of data verified.")}}this.info("Leaving..."),this.IS_STUB&&(await this.flashBegin(0,0),t.compress?await this.flashDeflFinish():await this.flashFinish())}async flashId(){this.debug("flash_id");let t=await this.readFlashId();this.info("Manufacturer: "+(255&t).toString(16));let e=t>>16&255;this.info("Device: "+(t>>8&255).toString(16)+e.toString(16)),this.info("Detected flash size: "+this.DETECTED_FLASH_SIZES[e])}async getFlashSize(){this.debug("flash_id");let t=await this.readFlashId();return this.DETECTED_FLASH_SIZES_NUM[t>>16&255]}async softReset(t){if(this.IS_STUB){if("ESP8266"!=this.chip.CHIP_NAME)throw new s("Soft resetting is currently only supported on ESP8266");t?(await this.flashBegin(0,0),await this.flashFinish(!0)):await this.command(this.ESP_RUN_USER_CODE,void 0,void 0,!1)}else{if(t)return;await this.flashBegin(0,0),await this.flashFinish(!1)}}async after(t="hard_reset",e){switch(t){case"hard_reset":if(this.resetConstructors.hardReset){this.info("Hard resetting via RTS pin...");let t=this.resetConstructors.hardReset(this.transport,e);await t.reset()}break;case"soft_reset":this.info("Soft resetting..."),await this.softReset(!1);break;case"no_reset_stub":this.info("Staying in flasher stub.");break;default:this.info("Staying in bootloader."),this.IS_STUB&&this.softReset(!0)}}}},257:function(t,e,i){"use strict";var s,r;t.exports=(null==(s=i.g.process)?void 0:s.env)&&"object"==typeof(null==(r=i.g.process)?void 0:r.env)?i.g.process:i(4227)},4227:function(t){!function(){var e={229:function(t){var e,i,s,r=t.exports={};function a(){throw Error("setTimeout has not been defined")}function n(){throw Error("clearTimeout has not been defined")}function h(t){if(e===setTimeout)return setTimeout(t,0);if((e===a||!e)&&setTimeout)return e=setTimeout,setTimeout(t,0);try{return e(t,0)}catch(i){try{return e.call(null,t,0)}catch(i){return e.call(this,t,0)}}}!function(){try{e="function"==typeof setTimeout?setTimeout:a}catch(t){e=a}try{i="function"==typeof clearTimeout?clearTimeout:n}catch(t){i=n}}();var o=[],l=!1,c=-1;function d(){l&&s&&(l=!1,s.length?o=s.concat(o):c=-1,o.length&&u())}function u(){if(!l){var t=h(d);l=!0;for(var e=o.length;e;){for(s=o,o=[];++c<e;)s&&s[c].run();c=-1,e=o.length}s=null,l=!1,function(t){if(i===clearTimeout)return clearTimeout(t);if((i===n||!i)&&clearTimeout)return i=clearTimeout,clearTimeout(t);try{i(t)}catch(e){try{return i.call(null,t)}catch(e){return i.call(this,t)}}}(t)}}function _(t,e){this.fun=t,this.array=e}function f(){}r.nextTick=function(t){var e=Array(arguments.length-1);if(arguments.length>1)for(var i=1;i<arguments.length;i++)e[i-1]=arguments[i];o.push(new _(t,e)),1!==o.length||l||h(u)},_.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=f,r.addListener=f,r.once=f,r.off=f,r.removeListener=f,r.removeAllListeners=f,r.emit=f,r.prependListener=f,r.prependOnceListener=f,r.listeners=function(t){return[]},r.binding=function(t){throw Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(t){throw Error("process.chdir is not supported")},r.umask=function(){return 0}}},i={};function s(t){var r=i[t];if(void 0!==r)return r.exports;var a=i[t]={exports:{}},n=!0;try{e[t](a,a.exports,s),n=!1}finally{n&&delete i[t]}return a.exports}s.ab="//";var r=s(229);t.exports=r}()}}]);