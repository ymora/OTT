# Règles Cursor pour le projet OTT - HAPPLYZ MEDICAL

## Architecture du projet
- **Backend**: PHP 8.3+ (API REST avec handlers modulaires) - JIT pour performances
- **Frontend**: Next.js 14 + React 18 (préparation Next.js 15 avec Server Actions)
- **Base de données**: PostgreSQL (base relationnelle robuste recommandée en 2025)
- **Hardware**: Firmware Arduino/ESP32
- **Scripts**: PowerShell pour audit et déploiement

## ⚠️ RÈGLE CRITIQUE - VÉRIFICATION AVANT TOUTE CRÉATION/MODIFICATION

**OBLIGATOIRE : Avant TOUTE création, modification ou correction, TOUJOURS :**

1. **Chercher d'abord dans le codebase existant** :
   - Utiliser `codebase_search` ou `grep` pour trouver les fonctions/composants/fichiers similaires
   - Vérifier si la fonctionnalité existe déjà avant de créer quelque chose de nouveau
   - Examiner les fichiers listés dans "Fichiers à consulter avant modifications" ci-dessous

2. **Vérifier les doublons potentiels** :
   - **Fichiers** : Vérifier qu'un fichier similaire n'existe pas déjà (même nom ou fonctionnalité similaire)
   - **Fonctions** : Chercher si une fonction similaire existe déjà (dans helpers, utils, etc.)
   - **Composants** : Vérifier si un composant React similaire existe déjà
   - **Scripts** : Vérifier si un script PowerShell/shell similaire existe déjà
   - **Endpoints API** : Vérifier si un endpoint similaire existe déjà dans `api.php` ou `api/handlers/`

3. **Éviter le code mort et les doublons** :
   - **NE PAS créer** de fonction/composant/fichier si une version similaire existe déjà
   - **Réutiliser** le code existant au lieu de créer une nouvelle version
   - **Refactorer** le code existant plutôt que créer un doublon
   - **Supprimer** les doublons identifiés au lieu d'en créer de nouveaux

4. **Avant toute modification de correction** :
   - Vérifier que la modification ne va pas créer de doublon
   - Vérifier que la modification ne va pas générer du code mort
   - Analyser l'impact : qui utilise cette fonction/composant ?
   - Consulter les fichiers liés pour comprendre le contexte complet

5. **Outils de vérification recommandés** :
   - `codebase_search` : Recherche sémantique pour trouver du code similaire
   - `grep` : Recherche textuelle exacte pour trouver les noms/fonctions
   - `glob_file_search` : Rechercher les fichiers par pattern
   - Scripts d'audit : Exécuter les scripts d'audit avant commit pour détecter les doublons

**Cette règle est CRITIQUE car les corrections qui génèrent des doublons ou du code mort aggravent les problèmes au lieu de les résoudre.**

## Principes de refactoring et maintenance

### Éviter la duplication de code - Application de la règle critique

**PROCESSUS OBLIGATOIRE avant toute création :**

1. **Recherche systématique** :
   - ✅ Utiliser `codebase_search` avec des mots-clés pertinents
   - ✅ Utiliser `grep` pour chercher les noms de fonctions/composants
   - ✅ Parcourir les dossiers concernés (`api/`, `components/`, `hooks/`, `lib/`, `scripts/`)
   - ✅ Vérifier les fichiers listés dans "Fichiers à consulter avant modifications"

2. **Vérification d'existence** :
   - **PHP**: TOUJOURS vérifier `api/helpers.php`, `api/helpers_sql.php`, `api/validators.php` AVANT de créer une fonction
   - **JavaScript**: TOUJOURS vérifier `lib/`, `hooks/`, `components/` AVANT de créer un composant/hook/utilitaire
   - **Scripts**: TOUJOURS vérifier `scripts/` et `scripts/audit/` AVANT de créer un script
   - **Fichiers**: TOUJOURS vérifier qu'un fichier similaire n'existe pas déjà (même dans d'autres dossiers)

3. **Réutiliser au lieu de créer** :
   - ✅ Si quelque chose existe déjà : **UTILISER** le code existant
   - ✅ Si le code existant ne fait pas exactement ce qu'il faut : **REFACTORER** plutôt que créer un doublon
   - ✅ Si plusieurs versions similaires existent : **UNIFIER** en une seule version

4. **Réutiliser les patterns existants** :
   - API handlers: Suivre la structure dans `api/handlers/`
   - Composants React: Réutiliser les patterns de `components/`
   - Hooks: Vérifier `hooks/` avant de créer de nouveaux hooks

5. **Centraliser la logique commune** :
   - Validation: Utiliser `api/validators.php` pour PHP
   - Appels API: Utiliser `lib/api.js` et `lib/apiHelpers.js` pour le frontend
   - Gestion d'erreurs: Utiliser `lib/errorHandler.js`

### Conventions de code

#### PHP (Backend) - Bonnes pratiques 2025

**Version et Performance:**
- **PHP 8.3+ recommandé**: Bénéficier du compilateur JIT pour de meilleures performances
- **Attributes PHP 8.0+**: Utiliser les attributes pour la métadonnée (remplace les annotations)
- **Typed properties**: Utiliser le typage strict pour les propriétés de classe
- **Match expressions**: Préférer `match` à `switch` pour les comparaisons strictes (PHP 8.0+)

**Sécurité:**
- **SÉCURITÉ CRITIQUE**: Toujours utiliser des requêtes préparées (PDO) - JAMAIS `$pdo->query($variable)` ou `$pdo->exec($variable)`
- Toujours valider les inputs avec les validators de `api/validators.php` avant traitement
- Valider les noms de fichiers pour éviter path traversal (utiliser `isValidFilename()`)
- Sanitizer les outputs avec `htmlspecialchars()` ou `json_encode()` selon le contexte
- Headers de sécurité: CORS, Content-Security-Policy, X-Frame-Options
- Rate limiting pour les endpoints sensibles (login, OTA, etc.)

**Code Quality:**
- Utiliser les fonctions de validation de `api/validators.php` (isValidEmail, isValidId, etc.)
- Utiliser les helpers SQL de `api/helpers_sql.php` pour les requêtes
- Suivre la structure modulaire des handlers dans `api/handlers/`
- Utiliser JWT pour l'authentification (fonctions dans `api/helpers.php`)
- Gestion d'erreurs: utiliser `try/catch` et logger les erreurs avec `error_log()`
- Retourner des réponses JSON cohérentes: `{success: bool, data?: any, error?: string}`

**Performance:**
- Utiliser le cache Redis pour les données fréquemment accédées
- Pagination pour les grandes listes (limite/offset ou cursor-based)
- Indexer les colonnes fréquemment utilisées dans les WHERE/JOIN
- Éviter les requêtes N+1 (utiliser JOIN ou requêtes groupées)

#### JavaScript/React (Frontend) - Bonnes pratiques 2025

**Next.js 14+ App Router (préparation Next.js 15):**
- **Server Components par défaut**: Ne pas utiliser `'use client'` sauf si nécessaire (interactivité, hooks, événements)
- **Client Components**: Utiliser uniquement pour composants interactifs (onClick, useState, useEffect, etc.)
- **Dynamic imports**: Utiliser `next/dynamic` avec `ssr: false` pour les composants lourds (cartes, graphiques)
- **Metadata**: Utiliser `export const metadata` dans les Server Components pour le SEO
- **Server Actions**: Préparer pour Next.js 15 - Server Actions pour les mutations (remplace les API routes pour les actions serveur)
- **Turbopack**: Utiliser `next dev --turbo` en développement pour de meilleures performances (Next.js 14+)

**React 18+ Patterns:**
- Utiliser les hooks personnalisés de `hooks/` (useApiData, useAsync, etc.)
- **IMPORTANT**: Pour les opérations CRUD, utiliser les hooks dédiés :
  - `useEntityArchive` pour l'archivage (NE PAS créer de `handleArchive` dupliqué)
  - `useEntityPermanentDelete` pour la suppression définitive (NE PAS créer de `handlePermanentDelete` dupliqué)
  - `useEntityRestore` pour la restauration (NE PAS créer de `handleRestore*` dupliqué)
  - `useEntityDelete` pour la suppression
- **Performance**: 
  - Utiliser `useMemo` pour les calculs coûteux (`.filter()`, `.map()`, `.find()` répétés)
  - Utiliser `useCallback` pour les fonctions passées en props aux composants enfants
  - Éviter les re-renders inutiles avec `React.memo()` pour les composants purs
- **Error Boundaries**: Toujours utiliser `ErrorBoundary` pour capturer les erreurs React
- **Suspense**: Utiliser `<Suspense>` pour les composants asynchrones et le lazy loading

**Sécurité Frontend:**
- Éviter `dangerouslySetInnerHTML` en React (risque XSS) sauf cas spécifiques documentés
- Sanitizer tout contenu utilisateur avant affichage
- Valider les données côté client ET serveur (défense en profondeur)

**Accessibilité (a11y) - WCAG 2.1 AA:**
- Toujours ajouter `aria-label` aux boutons icon-only
- Utiliser des balises sémantiques (`<button>`, `<nav>`, `<main>`, `<header>`, etc.)
- Gérer le focus clavier (tabindex, focus visible)
- Contraste des couleurs: minimum 4.5:1 pour le texte normal, 3:1 pour le texte large
- Attributs ARIA appropriés (`aria-expanded`, `aria-controls`, `aria-live` pour les notifications)
- Labels pour les formulaires: toujours associer `<label>` aux inputs ou utiliser `aria-labelledby`
- Navigation clavier: tous les éléments interactifs doivent être accessibles au clavier

**Gestion d'erreurs:**
- Utiliser `ErrorMessage` pour les erreurs utilisateur
- Utiliser `ErrorBoundary` pour les erreurs React
- Logger les erreurs avec `logger.error()` (intégration Sentry)
- Afficher des messages d'erreur clairs et actionnables
- Fournir des actions de récupération (retry, retour à l'accueil)

**Code Quality:**
- Réutiliser les composants de `components/` avant d'en créer de nouveaux
- Utiliser `lib/api.js` pour tous les appels API
- Suivre les patterns de `contexts/` pour la gestion d'état global
- Éviter les variables inutilisées (le script d'audit les détecte)
- Nommer les composants avec des noms descriptifs (PascalCase)
- Extraire la logique métier dans des hooks personnalisés

#### Base de données - Bonnes pratiques 2025
- **PostgreSQL**: Base relationnelle robuste recommandée en 2025 pour la majorité des cas d'usage
- **Sécurité**: Toujours utiliser des requêtes préparées (PDO) - JAMAIS de concaténation SQL
- **Migrations**: Vérifier les migrations dans `sql/` avant de modifier le schéma
- **Permissions**: Respecter les contraintes de rôles et permissions (admin, medecin, technicien)
- **Indexation**: Créer des index sur les colonnes fréquemment utilisées dans WHERE/JOIN
  - Utiliser `EXPLAIN ANALYZE` pour analyser les performances des requêtes
  - Index partiels pour les requêtes avec conditions fréquentes
- **Transactions**: Utiliser des transactions pour les opérations multi-étapes
- **Contraintes**: Utiliser les contraintes DB (FOREIGN KEY, UNIQUE, CHECK) pour l'intégrité
- **Backup**: Toujours tester les migrations sur un environnement de test avant production
- **Connection Pooling**: Utiliser le pooling de connexions pour améliorer les performances

### Refactoring
- **Avant de refactorer**: 
  1. ✅ **Chercher les doublons** : Utiliser `codebase_search` et `grep` pour trouver toutes les occurrences similaires
  2. ✅ **Analyser l'impact** : Identifier TOUS les fichiers qui utilisent la fonction/classe
  3. ✅ **Vérifier les dépendances** : Comprendre qui dépend de quoi
  4. ✅ **Planifier la consolidation** : Si plusieurs versions existent, prévoir leur unification
- **Pendant le refactoring**:
  - ✅ **Ne pas créer de doublons** : Réutiliser le code existant au lieu de créer de nouvelles versions
  - ✅ **Supprimer les anciennes versions** : Après consolidation, supprimer les versions obsolètes
- **Après refactoring**: 
  - ✅ Vérifier que tous les tests passent
  - ✅ Vérifier qu'aucun doublon n'a été créé (utiliser les scripts d'audit)
  - ✅ Vérifier qu'aucun code mort n'a été généré
- **Documentation**: Mettre à jour les commentaires et la documentation si nécessaire

### Maintenance et Architecture

**Principes SOLID:**
- **DRY (Don't Repeat Yourself)**: Toujours factoriser le code dupliqué
- **Single Responsibility**: Chaque fonction/classe doit avoir une seule responsabilité
- **Open/Closed**: Ouvert à l'extension, fermé à la modification
- **Liskov Substitution**: Les sous-types doivent être substituables à leurs types de base
- **Interface Segregation**: Préférer des interfaces spécifiques plutôt que générales
- **Dependency Inversion**: Dépendre d'abstractions, pas de concrétions

**Code Quality:**
- **Consistance**: Suivre les patterns existants dans le projet
- **Nommage**: Noms descriptifs et cohérents (camelCase pour JS, snake_case pour PHP)
- **Commentaires**: Documenter le "pourquoi", pas le "quoi" (le code doit être auto-explicatif)
- **Complexité**: Limiter la complexité cyclomatique (< 10 par fonction)
- **Taille**: Limiter la taille des fichiers (< 500 lignes selon l'audit)

## Fichiers à consulter avant modifications

### Pour le backend PHP
- `api/helpers.php` - Fonctions utilitaires générales
- `api/helpers_sql.php` - Helpers pour requêtes SQL
- `api/validators.php` - Validateurs d'inputs
- `api/handlers/` - Structure des handlers API

### Pour le frontend React
- `lib/api.js` - Appels API centralisés
- `lib/apiHelpers.js` - Helpers pour API
- `hooks/` - Hooks personnalisés réutilisables
- `components/` - Composants réutilisables
- `contexts/` - Contextes React globaux

### Pour la base de données
- `sql/schema.sql` - Schéma de base
- `sql/migration.sql` - Migrations

## Tests et Qualité

**Tests:**
- **Unitaires**: Tester les fonctions utilitaires et hooks isolément
- **Intégration**: Tester les interactions entre composants et API
- **E2E**: Tester les flux utilisateur complets (quand framework E2E sera ajouté)
- Commandes: `npm test`, `npm run test:watch`, `npm run test:coverage`
- Objectif: Couverture > 70% pour les fonctions critiques

**Linting et Formatting:**
- `npm run lint` - Vérifier les erreurs ESLint
- Respecter les règles ESLint configurées dans `.eslintrc.json`
- Formater le code avant commit (Prettier si configuré)

**Build:**
- `npm run build` - Vérifier que le build passe sans erreurs
- `npm run export` - Tester l'export statique pour GitHub Pages

## Notes importantes
- Le projet utilise JWT pour l'authentification
- Les rôles sont: admin, medecin, technicien
- Toujours vérifier les permissions avant d'implémenter une fonctionnalité
- Le firmware est dans `hardware/firmware/`
- Les scripts d'audit sont dans `scripts/audit/`

## ⚠️ RÈGLES CRITIQUES - TIMEOUTS ET COMMANDES LONGUES

**OBLIGATOIRE : Pour toutes les commandes qui peuvent prendre du temps ou se bloquer :**

1. **Timeouts pour les commandes terminales** :
   - **Tests de compilation firmware** : Utiliser des timeouts adaptés (minimum 10-15 minutes)
   - **Requêtes API longues** : Timeout de 30 secondes minimum, 2-5 minutes pour les opérations longues
   - **Connexions SSE** : Pas de timeout (utiliser `-1` ou `0` pour désactiver) car la compilation peut prendre 10-30 minutes
   - **Scripts PowerShell** : Utiliser `-TimeoutSec` approprié ou désactiver avec `-1` pour les opérations longues

2. **Gestion des timeouts dans les scripts** :
   - **PowerShell** : 
     - `Invoke-RestMethod -TimeoutSec 30` pour les requêtes normales
     - `Invoke-RestMethod -TimeoutSec 600` (10 min) pour les opérations longues
     - `$request.Timeout = -1` pour désactiver le timeout (SSE, compilation)
   - **PHP** :
     - `set_time_limit(0)` pour les scripts longs (compilation firmware)
     - `ignore_user_abort(true)` pour continuer même si le client se déconnecte
   - **JavaScript/Node.js** :
     - `fetch()` avec `signal: AbortSignal.timeout(30000)` pour les requêtes normales
     - Pas de timeout pour EventSource (SSE) - la connexion reste ouverte

3. **Tests et surveillance en continu** :
   - **Ne jamais planter** : Les scripts de test doivent continuer même en cas d'erreur
   - **Vérification périodique** : Vérifier le statut toutes les 30-60 secondes en arrière-plan
   - **Heartbeat** : Afficher un message toutes les 60 secondes pour montrer que le script est actif
   - **Timeout de sécurité** : Maximum 30 minutes pour éviter les boucles infinies

4. **Compilation firmware - Timeouts spécifiques** :
   - **SSE Connection** : Pas de timeout (`-1` ou `0`)
   - **Keep-alive** : Toutes les 1 seconde (éviter les timeouts de connexion)
   - **Vérification statut** : Toutes les 30 secondes en arrière-plan
   - **Timeout global** : 30 minutes maximum (sécurité)
   - **Gestion erreurs** : Continuer même si la connexion SSE se ferme (vérifier le statut en DB)

5. **Commandes à exécuter en arrière-plan** :
   - Utiliser `is_background: true` pour les commandes longues qui doivent continuer
   - Pour les tests interactifs : Utiliser `is_background: false` mais avec timeouts adaptés

6. **Exemples de timeouts recommandés** :
   ```powershell
   # Requête API normale
   Invoke-RestMethod -Uri $url -TimeoutSec 30
   
   # Opération longue (upload, compilation)
   Invoke-RestMethod -Uri $url -TimeoutSec 600
   
   # SSE/Streaming (pas de timeout)
   $request.Timeout = -1
   $request.ReadWriteTimeout = -1
   
   # PHP script long
   set_time_limit(0);
   ignore_user_abort(true);
   ```

**Cette règle est CRITIQUE pour éviter que les tests et scripts se bloquent indéfiniment.**

## Relation avec le script d'audit automatique

Le script `scripts/AUDIT_COMPLET_AUTOMATIQUE.ps1` vérifie automatiquement :
- Code mort (composants/hooks/libs non utilisés)
- Duplication de code (notamment handleArchive, handlePermanentDelete, handleRestore*)
- Complexité (fichiers > 500 lignes)
- Sécurité (SQL injection, XSS)
- Performance (optimisations React, variables inutilisées)
- Tests API fonctionnels
- Base de données (cohérence, intégrité)
- Documentation et organisation

**Ces règles `.cursorrules` visent à éviter ces problèmes AVANT qu'ils ne soient détectés par l'audit.**

### Workflow recommandé
1. **AVANT TOUT DÉVELOPPEMENT** : 
   - ✅ **OBLIGATOIRE** : Utiliser `codebase_search` et `grep` pour chercher le code existant
   - ✅ **OBLIGATOIRE** : Vérifier qu'aucun doublon n'existe avant de créer quoi que ce soit
   - ✅ **OBLIGATOIRE** : Réutiliser le code existant au lieu de créer du nouveau code

2. **Développement** : Suivre les règles `.cursorrules` pour éviter les problèmes

3. **Avant commit** : 
   - ✅ Vérifier manuellement qu'aucun doublon n'a été créé
   - Exécuter `npm run lint` pour vérifier le code
   - Exécuter `npm test` pour vérifier les tests
   - Exécuter `scripts/AUDIT_COMPLET_AUTOMATIQUE.ps1` pour audit complet (détecte les doublons et code mort)

4. **Correction** : 
   - ✅ **CRITIQUE** : Vérifier que la correction ne génère pas de doublons ou de code mort
   - ✅ Utiliser les recommandations de l'audit pour corriger les problèmes détectés
   - ✅ Préférer la consolidation à la multiplication (unifier plutôt que dupliquer)

5. **Code Review** : 
   - ✅ Vérifier qu'aucun doublon n'a été introduit
   - Vérifier l'accessibilité, la sécurité, et les performances

## Bonnes pratiques spécifiques 2025

### Performance Web
- **Core Web Vitals**: Optimiser LCP (< 2.5s), FID (< 100ms), CLS (< 0.1)
- **Code Splitting**: Utiliser dynamic imports pour les composants lourds
- **Images**: Utiliser `next/image` avec lazy loading et formats modernes (WebP, AVIF)
- **Fonts**: Utiliser `next/font` pour optimiser le chargement des polices
- **Bundle Size**: Surveiller la taille du bundle avec `npm run build -- --analyze`

### SEO et Métadonnées
- Utiliser `export const metadata` dans les Server Components
- Ajouter des Open Graph tags pour les réseaux sociaux
- Sitemap et robots.txt pour l'indexation
- Structured data (JSON-LD) pour les données structurées

### Internationalisation (i18n) - Préparation
- Préparer le code pour l'i18n (éviter les strings hardcodées)
- Utiliser des clés de traduction plutôt que du texte direct
- Structure: `t('common.save')` au lieu de `"Enregistrer"`

### TypeScript - Préparation future (Recommandé en 2025)
- **Next.js 15 + TypeScript**: Combinaison recommandée pour le développement frontend en 2025
- Préparer la migration vers TypeScript:
  - Ajouter des JSDoc avec types (`@param {string} name`)
  - Éviter `any` et utiliser des types explicites
  - Créer des interfaces/types pour les données API
  - Utiliser `@ts-check` en haut des fichiers JS pour validation progressive
  - Migrer progressivement: commencer par les utilitaires, puis les hooks, puis les composants

### Monitoring et Observabilité
- Utiliser Sentry pour le monitoring d'erreurs (déjà configuré)
- Logger les actions importantes avec `logger.info/warn/error`
- Ajouter des métriques de performance (temps de réponse API, etc.)
- **OpenTelemetry**: Considérer l'ajout d'OpenTelemetry pour le tracing distribué (2025)

### Outils d'IA pour le développement (2025)
- **Claude Sonnet 4.5**: Recommandé pour le refactoring et la maintenance (compréhension contextuelle)
- **GPT-5**: Performances améliorées pour la génération de code (si disponible)
- **Cursor**: Utiliser les modèles avancés pour éviter la duplication de code
- **Code Review IA**: Utiliser l'IA pour identifier les vulnérabilités et améliorations

## Patterns spécifiques pour composants courants

### Formulaires
- Toujours utiliser `<label>` associé aux inputs (ou `aria-labelledby`)
- Grouper les champs liés avec `<fieldset>` et `<legend>`
- Valider côté client ET serveur
- Afficher les erreurs de validation de manière accessible (`aria-describedby`, `aria-invalid`)
- Gérer le focus après soumission (succès ou erreur)
- Utiliser `type="email"`, `type="tel"`, etc. pour la validation native

### Tables de données
- Utiliser `<table>` avec `<thead>`, `<tbody>`, `<tfoot>` sémantiques
- Ajouter `scope="col"` ou `scope="row"` aux en-têtes
- Pour les tables complexes, utiliser `aria-label` ou `<caption>`
- Rendre les tables responsives (scroll horizontal ou cards sur mobile)
- Pagination accessible (boutons avec labels clairs)

### Modals et Dialogs
- Utiliser `role="dialog"` et `aria-modal="true"`
- Gérer le focus trap (focus reste dans le modal)
- Fermer avec Escape (gérer `onKeyDown`)
- Retourner le focus à l'élément déclencheur après fermeture
- Ajouter `aria-labelledby` pointant vers le titre du modal

### Navigation
- Utiliser `<nav>` pour les menus de navigation
- Indiquer la page active avec `aria-current="page"`
- Menus déroulants: utiliser `aria-expanded` et `aria-controls`
- Breadcrumbs: utiliser `<nav aria-label="Breadcrumb">` avec structure sémantique

### Loading States
- Utiliser `aria-live="polite"` pour les mises à jour de contenu
- Afficher des messages de chargement accessibles (`aria-busy="true"`)
- Skeleton screens plutôt que spinners pour un meilleur UX

## Anti-patterns à éviter

### React/Next.js
- ❌ Ne pas utiliser `'use client'` inutilement (préférer Server Components)
- ❌ Ne pas créer de fonctions inline dans le JSX (utiliser `useCallback`)
- ❌ Ne pas utiliser `index` comme clé dans les listes (utiliser un ID unique)
- ❌ Ne pas oublier de nettoyer les effets (`useEffect` cleanup)
- ❌ Ne pas muter directement l'état (toujours créer un nouvel objet/tableau)

### PHP
- ❌ Ne jamais concaténer des variables dans les requêtes SQL
- ❌ Ne pas utiliser `extract()` ou `eval()` (risques de sécurité)
- ❌ Ne pas exposer les détails d'erreurs en production
- ❌ Ne pas oublier de valider les types de données

### Général
- ❌ **CRITIQUE**: Ne jamais créer de code sans avoir d'abord cherché dans le codebase existant
- ❌ **CRITIQUE**: Ne pas créer de doublons (fonctions, composants, fichiers similaires)
- ❌ **CRITIQUE**: Ne pas générer de code mort en créant de nouvelles versions au lieu de réutiliser l'existant
- ❌ Ne pas hardcoder les URLs ou chemins (utiliser des constantes/config)
- ❌ Ne pas ignorer les warnings du linter
- ❌ Ne pas commiter les secrets ou tokens (utiliser des variables d'environnement)
- ❌ Ne pas créer de dépendances circulaires
- ❌ Ne pas créer plusieurs fichiers/composants qui font la même chose (unifier au lieu de multiplier)

### Documentation (Fichiers MD/TXT)
- ❌ **INTERDIT**: Créer de nouveaux fichiers `.md` ou `.txt` à chaque chat pour éviter de polluer le projet
- ✅ **OBLIGATOIRE**: Consolider et réorganiser les MD existants au lieu d'en créer de nouveaux
- ✅ **LIMITE STRICTE**: Maximum 4-5 fichiers MD dans `public/` pour la documentation accessible depuis le menu
- ✅ **Documents existants à utiliser** :
  - `README.md` (racine) - Documentation principale du projet
  - `public/SUIVI_TEMPS_FACTURATION.md` - Suivi du temps (accessible depuis le menu)
  - `docs/SYNCHRONISATION_DEPLOIEMENT.md` - Guide de synchronisation GitHub Pages
  - `public/docs/DOCUMENTATION_*.html` - Documents HTML accessibles depuis le menu (3 documents)
- ✅ **Avant de créer un nouveau MD** :
  1. Vérifier si l'information peut être ajoutée à un MD existant
  2. Vérifier si l'information peut être ajoutée aux documents HTML dans `public/docs/`
  3. Vérifier si l'information peut être ajoutée au README.md
  4. Seulement si vraiment nécessaire : créer un nouveau MD spécifique (maximum 2-3 MD supplémentaires autorisés)
- ❌ **À SUPPRIMER**: Les MD temporaires d'audit à la racine (AUDIT_EN_COURS.md, SUPPRESSION_DOUBLON_AUDIT.md, etc.) doivent être supprimés après utilisation
- ✅ **Principe**: Mettre à jour les MD existants plutôt que d'en créer de nouveaux