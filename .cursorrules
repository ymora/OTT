# Règles Cursor pour le projet OTT - HAPPLYZ MEDICAL

## Architecture du projet
- **Backend**: PHP 8.3+ (API REST avec handlers modulaires) - JIT pour performances
- **Frontend**: Next.js 14 + React 18 (préparation Next.js 15 avec Server Actions)
- **Base de données**: PostgreSQL (base relationnelle robuste recommandée en 2025)
- **Hardware**: Firmware Arduino/ESP32
- **Scripts**: PowerShell pour audit et déploiement

## Principes de refactoring et maintenance

### Éviter la duplication de code
1. **Toujours vérifier l'existence de fonctions utilitaires avant d'en créer de nouvelles**
   - PHP: Vérifier `api/helpers.php`, `api/helpers_sql.php`, `api/validators.php`
   - JavaScript: Vérifier `lib/`, `hooks/`, `components/`
   
2. **Réutiliser les patterns existants**
   - API handlers: Suivre la structure dans `api/handlers/`
   - Composants React: Réutiliser les patterns de `components/`
   - Hooks: Vérifier `hooks/` avant de créer de nouveaux hooks

3. **Centraliser la logique commune**
   - Validation: Utiliser `api/validators.php` pour PHP
   - Appels API: Utiliser `lib/api.js` et `lib/apiHelpers.js` pour le frontend
   - Gestion d'erreurs: Utiliser `lib/errorHandler.js`

### Conventions de code

#### PHP (Backend) - Bonnes pratiques 2025

**Version et Performance:**
- **PHP 8.3+ recommandé**: Bénéficier du compilateur JIT pour de meilleures performances
- **Attributes PHP 8.0+**: Utiliser les attributes pour la métadonnée (remplace les annotations)
- **Typed properties**: Utiliser le typage strict pour les propriétés de classe
- **Match expressions**: Préférer `match` à `switch` pour les comparaisons strictes (PHP 8.0+)

**Sécurité:**
- **SÉCURITÉ CRITIQUE**: Toujours utiliser des requêtes préparées (PDO) - JAMAIS `$pdo->query($variable)` ou `$pdo->exec($variable)`
- Toujours valider les inputs avec les validators de `api/validators.php` avant traitement
- Valider les noms de fichiers pour éviter path traversal (utiliser `isValidFilename()`)
- Sanitizer les outputs avec `htmlspecialchars()` ou `json_encode()` selon le contexte
- Headers de sécurité: CORS, Content-Security-Policy, X-Frame-Options
- Rate limiting pour les endpoints sensibles (login, OTA, etc.)

**Code Quality:**
- Utiliser les fonctions de validation de `api/validators.php` (isValidEmail, isValidId, etc.)
- Utiliser les helpers SQL de `api/helpers_sql.php` pour les requêtes
- Suivre la structure modulaire des handlers dans `api/handlers/`
- Utiliser JWT pour l'authentification (fonctions dans `api/helpers.php`)
- Gestion d'erreurs: utiliser `try/catch` et logger les erreurs avec `error_log()`
- Retourner des réponses JSON cohérentes: `{success: bool, data?: any, error?: string}`

**Performance:**
- Utiliser le cache Redis pour les données fréquemment accédées
- Pagination pour les grandes listes (limite/offset ou cursor-based)
- Indexer les colonnes fréquemment utilisées dans les WHERE/JOIN
- Éviter les requêtes N+1 (utiliser JOIN ou requêtes groupées)

#### JavaScript/React (Frontend) - Bonnes pratiques 2025

**Next.js 14+ App Router (préparation Next.js 15):**
- **Server Components par défaut**: Ne pas utiliser `'use client'` sauf si nécessaire (interactivité, hooks, événements)
- **Client Components**: Utiliser uniquement pour composants interactifs (onClick, useState, useEffect, etc.)
- **Dynamic imports**: Utiliser `next/dynamic` avec `ssr: false` pour les composants lourds (cartes, graphiques)
- **Metadata**: Utiliser `export const metadata` dans les Server Components pour le SEO
- **Server Actions**: Préparer pour Next.js 15 - Server Actions pour les mutations (remplace les API routes pour les actions serveur)
- **Turbopack**: Utiliser `next dev --turbo` en développement pour de meilleures performances (Next.js 14+)

**React 18+ Patterns:**
- Utiliser les hooks personnalisés de `hooks/` (useApiData, useAsync, etc.)
- **IMPORTANT**: Pour les opérations CRUD, utiliser les hooks dédiés :
  - `useEntityArchive` pour l'archivage (NE PAS créer de `handleArchive` dupliqué)
  - `useEntityPermanentDelete` pour la suppression définitive (NE PAS créer de `handlePermanentDelete` dupliqué)
  - `useEntityRestore` pour la restauration (NE PAS créer de `handleRestore*` dupliqué)
  - `useEntityDelete` pour la suppression
- **Performance**: 
  - Utiliser `useMemo` pour les calculs coûteux (`.filter()`, `.map()`, `.find()` répétés)
  - Utiliser `useCallback` pour les fonctions passées en props aux composants enfants
  - Éviter les re-renders inutiles avec `React.memo()` pour les composants purs
- **Error Boundaries**: Toujours utiliser `ErrorBoundary` pour capturer les erreurs React
- **Suspense**: Utiliser `<Suspense>` pour les composants asynchrones et le lazy loading

**Sécurité Frontend:**
- Éviter `dangerouslySetInnerHTML` en React (risque XSS) sauf cas spécifiques documentés
- Sanitizer tout contenu utilisateur avant affichage
- Valider les données côté client ET serveur (défense en profondeur)

**Accessibilité (a11y) - WCAG 2.1 AA:**
- Toujours ajouter `aria-label` aux boutons icon-only
- Utiliser des balises sémantiques (`<button>`, `<nav>`, `<main>`, `<header>`, etc.)
- Gérer le focus clavier (tabindex, focus visible)
- Contraste des couleurs: minimum 4.5:1 pour le texte normal, 3:1 pour le texte large
- Attributs ARIA appropriés (`aria-expanded`, `aria-controls`, `aria-live` pour les notifications)
- Labels pour les formulaires: toujours associer `<label>` aux inputs ou utiliser `aria-labelledby`
- Navigation clavier: tous les éléments interactifs doivent être accessibles au clavier

**Gestion d'erreurs:**
- Utiliser `ErrorMessage` pour les erreurs utilisateur
- Utiliser `ErrorBoundary` pour les erreurs React
- Logger les erreurs avec `logger.error()` (intégration Sentry)
- Afficher des messages d'erreur clairs et actionnables
- Fournir des actions de récupération (retry, retour à l'accueil)

**Code Quality:**
- Réutiliser les composants de `components/` avant d'en créer de nouveaux
- Utiliser `lib/api.js` pour tous les appels API
- Suivre les patterns de `contexts/` pour la gestion d'état global
- Éviter les variables inutilisées (le script d'audit les détecte)
- Nommer les composants avec des noms descriptifs (PascalCase)
- Extraire la logique métier dans des hooks personnalisés

#### Base de données - Bonnes pratiques 2025
- **PostgreSQL**: Base relationnelle robuste recommandée en 2025 pour la majorité des cas d'usage
- **Sécurité**: Toujours utiliser des requêtes préparées (PDO) - JAMAIS de concaténation SQL
- **Migrations**: Vérifier les migrations dans `sql/` avant de modifier le schéma
- **Permissions**: Respecter les contraintes de rôles et permissions (admin, medecin, technicien)
- **Indexation**: Créer des index sur les colonnes fréquemment utilisées dans WHERE/JOIN
  - Utiliser `EXPLAIN ANALYZE` pour analyser les performances des requêtes
  - Index partiels pour les requêtes avec conditions fréquentes
- **Transactions**: Utiliser des transactions pour les opérations multi-étapes
- **Contraintes**: Utiliser les contraintes DB (FOREIGN KEY, UNIQUE, CHECK) pour l'intégrité
- **Backup**: Toujours tester les migrations sur un environnement de test avant production
- **Connection Pooling**: Utiliser le pooling de connexions pour améliorer les performances

### Refactoring
- **Avant de refactorer**: Analyser l'impact sur tous les fichiers qui utilisent la fonction/classe
- **Après refactoring**: Vérifier que tous les tests passent
- **Documentation**: Mettre à jour les commentaires et la documentation si nécessaire

### Maintenance et Architecture

**Principes SOLID:**
- **DRY (Don't Repeat Yourself)**: Toujours factoriser le code dupliqué
- **Single Responsibility**: Chaque fonction/classe doit avoir une seule responsabilité
- **Open/Closed**: Ouvert à l'extension, fermé à la modification
- **Liskov Substitution**: Les sous-types doivent être substituables à leurs types de base
- **Interface Segregation**: Préférer des interfaces spécifiques plutôt que générales
- **Dependency Inversion**: Dépendre d'abstractions, pas de concrétions

**Code Quality:**
- **Consistance**: Suivre les patterns existants dans le projet
- **Nommage**: Noms descriptifs et cohérents (camelCase pour JS, snake_case pour PHP)
- **Commentaires**: Documenter le "pourquoi", pas le "quoi" (le code doit être auto-explicatif)
- **Complexité**: Limiter la complexité cyclomatique (< 10 par fonction)
- **Taille**: Limiter la taille des fichiers (< 500 lignes selon l'audit)

## Fichiers à consulter avant modifications

### Pour le backend PHP
- `api/helpers.php` - Fonctions utilitaires générales
- `api/helpers_sql.php` - Helpers pour requêtes SQL
- `api/validators.php` - Validateurs d'inputs
- `api/handlers/` - Structure des handlers API

### Pour le frontend React
- `lib/api.js` - Appels API centralisés
- `lib/apiHelpers.js` - Helpers pour API
- `hooks/` - Hooks personnalisés réutilisables
- `components/` - Composants réutilisables
- `contexts/` - Contextes React globaux

### Pour la base de données
- `sql/schema.sql` - Schéma de base
- `sql/migration.sql` - Migrations

## Tests et Qualité

**Tests:**
- **Unitaires**: Tester les fonctions utilitaires et hooks isolément
- **Intégration**: Tester les interactions entre composants et API
- **E2E**: Tester les flux utilisateur complets (quand framework E2E sera ajouté)
- Commandes: `npm test`, `npm run test:watch`, `npm run test:coverage`
- Objectif: Couverture > 70% pour les fonctions critiques

**Linting et Formatting:**
- `npm run lint` - Vérifier les erreurs ESLint
- Respecter les règles ESLint configurées dans `.eslintrc.json`
- Formater le code avant commit (Prettier si configuré)

**Build:**
- `npm run build` - Vérifier que le build passe sans erreurs
- `npm run export` - Tester l'export statique pour GitHub Pages

## Notes importantes
- Le projet utilise JWT pour l'authentification
- Les rôles sont: admin, medecin, technicien
- Toujours vérifier les permissions avant d'implémenter une fonctionnalité
- Le firmware est dans `hardware/firmware/`
- Les scripts d'audit sont dans `scripts/audit/`

## Relation avec le script d'audit automatique

Le script `scripts/AUDIT_COMPLET_AUTOMATIQUE.ps1` vérifie automatiquement :
- Code mort (composants/hooks/libs non utilisés)
- Duplication de code (notamment handleArchive, handlePermanentDelete, handleRestore*)
- Complexité (fichiers > 500 lignes)
- Sécurité (SQL injection, XSS)
- Performance (optimisations React, variables inutilisées)
- Tests API fonctionnels
- Base de données (cohérence, intégrité)
- Documentation et organisation

**Ces règles `.cursorrules` visent à éviter ces problèmes AVANT qu'ils ne soient détectés par l'audit.**

### Workflow recommandé
1. **Développement** : Suivre les règles `.cursorrules` pour éviter les problèmes
2. **Avant commit** : 
   - Exécuter `npm run lint` pour vérifier le code
   - Exécuter `npm test` pour vérifier les tests
   - Exécuter `scripts/AUDIT_COMPLET_AUTOMATIQUE.ps1` pour audit complet
3. **Correction** : Utiliser les recommandations de l'audit pour corriger les problèmes détectés
4. **Code Review** : Vérifier l'accessibilité, la sécurité, et les performances

## Bonnes pratiques spécifiques 2025

### Performance Web
- **Core Web Vitals**: Optimiser LCP (< 2.5s), FID (< 100ms), CLS (< 0.1)
- **Code Splitting**: Utiliser dynamic imports pour les composants lourds
- **Images**: Utiliser `next/image` avec lazy loading et formats modernes (WebP, AVIF)
- **Fonts**: Utiliser `next/font` pour optimiser le chargement des polices
- **Bundle Size**: Surveiller la taille du bundle avec `npm run build -- --analyze`

### SEO et Métadonnées
- Utiliser `export const metadata` dans les Server Components
- Ajouter des Open Graph tags pour les réseaux sociaux
- Sitemap et robots.txt pour l'indexation
- Structured data (JSON-LD) pour les données structurées

### Internationalisation (i18n) - Préparation
- Préparer le code pour l'i18n (éviter les strings hardcodées)
- Utiliser des clés de traduction plutôt que du texte direct
- Structure: `t('common.save')` au lieu de `"Enregistrer"`

### TypeScript - Préparation future (Recommandé en 2025)
- **Next.js 15 + TypeScript**: Combinaison recommandée pour le développement frontend en 2025
- Préparer la migration vers TypeScript:
  - Ajouter des JSDoc avec types (`@param {string} name`)
  - Éviter `any` et utiliser des types explicites
  - Créer des interfaces/types pour les données API
  - Utiliser `@ts-check` en haut des fichiers JS pour validation progressive
  - Migrer progressivement: commencer par les utilitaires, puis les hooks, puis les composants

### Monitoring et Observabilité
- Utiliser Sentry pour le monitoring d'erreurs (déjà configuré)
- Logger les actions importantes avec `logger.info/warn/error`
- Ajouter des métriques de performance (temps de réponse API, etc.)
- **OpenTelemetry**: Considérer l'ajout d'OpenTelemetry pour le tracing distribué (2025)

### Outils d'IA pour le développement (2025)
- **Claude Sonnet 4.5**: Recommandé pour le refactoring et la maintenance (compréhension contextuelle)
- **GPT-5**: Performances améliorées pour la génération de code (si disponible)
- **Cursor**: Utiliser les modèles avancés pour éviter la duplication de code
- **Code Review IA**: Utiliser l'IA pour identifier les vulnérabilités et améliorations

## Patterns spécifiques pour composants courants

### Formulaires
- Toujours utiliser `<label>` associé aux inputs (ou `aria-labelledby`)
- Grouper les champs liés avec `<fieldset>` et `<legend>`
- Valider côté client ET serveur
- Afficher les erreurs de validation de manière accessible (`aria-describedby`, `aria-invalid`)
- Gérer le focus après soumission (succès ou erreur)
- Utiliser `type="email"`, `type="tel"`, etc. pour la validation native

### Tables de données
- Utiliser `<table>` avec `<thead>`, `<tbody>`, `<tfoot>` sémantiques
- Ajouter `scope="col"` ou `scope="row"` aux en-têtes
- Pour les tables complexes, utiliser `aria-label` ou `<caption>`
- Rendre les tables responsives (scroll horizontal ou cards sur mobile)
- Pagination accessible (boutons avec labels clairs)

### Modals et Dialogs
- Utiliser `role="dialog"` et `aria-modal="true"`
- Gérer le focus trap (focus reste dans le modal)
- Fermer avec Escape (gérer `onKeyDown`)
- Retourner le focus à l'élément déclencheur après fermeture
- Ajouter `aria-labelledby` pointant vers le titre du modal

### Navigation
- Utiliser `<nav>` pour les menus de navigation
- Indiquer la page active avec `aria-current="page"`
- Menus déroulants: utiliser `aria-expanded` et `aria-controls`
- Breadcrumbs: utiliser `<nav aria-label="Breadcrumb">` avec structure sémantique

### Loading States
- Utiliser `aria-live="polite"` pour les mises à jour de contenu
- Afficher des messages de chargement accessibles (`aria-busy="true"`)
- Skeleton screens plutôt que spinners pour un meilleur UX

## Anti-patterns à éviter

### React/Next.js
- ❌ Ne pas utiliser `'use client'` inutilement (préférer Server Components)
- ❌ Ne pas créer de fonctions inline dans le JSX (utiliser `useCallback`)
- ❌ Ne pas utiliser `index` comme clé dans les listes (utiliser un ID unique)
- ❌ Ne pas oublier de nettoyer les effets (`useEffect` cleanup)
- ❌ Ne pas muter directement l'état (toujours créer un nouvel objet/tableau)

### PHP
- ❌ Ne jamais concaténer des variables dans les requêtes SQL
- ❌ Ne pas utiliser `extract()` ou `eval()` (risques de sécurité)
- ❌ Ne pas exposer les détails d'erreurs en production
- ❌ Ne pas oublier de valider les types de données

### Général
- ❌ Ne pas hardcoder les URLs ou chemins (utiliser des constantes/config)
- ❌ Ne pas ignorer les warnings du linter
- ❌ Ne pas commiter les secrets ou tokens (utiliser des variables d'environnement)
- ❌ Ne pas créer de dépendances circulaires
